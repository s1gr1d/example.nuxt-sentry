{"version":3,"file":"client-db-UJ3_M7mT.mjs","sources":["../../../../../node_modules/@nuxt/content/dist/runtime/query/match/index.js","../../../../../node_modules/@nuxt/content/dist/runtime/query/match/pipeline.js","../../../../../node_modules/@nuxt/content/dist/runtime/query/match/pipeline-legacy.js","../../../../../node_modules/@nuxt/content/dist/runtime/transformers/path-meta.js","../../../../../node_modules/@nuxt/content/dist/runtime/server/navigation.js","../../../../../node_modules/@nuxt/content/dist/runtime/legacy/composables/client-db.js"],"sourcesContent":["import { assertArray, ensureArray, get } from \"./utils.js\";\nexport function createMatch(opts = {}) {\n  const operators = createOperators(match, opts.operators);\n  function match(item, conditions) {\n    if (typeof conditions !== \"object\" || conditions instanceof RegExp) {\n      return operators.$eq(item, conditions);\n    }\n    return Object.keys(conditions || {}).every((key) => {\n      const condition = conditions[key];\n      if (key.startsWith(\"$\") && operators[key]) {\n        const fn = operators[key];\n        return typeof fn === \"function\" ? fn(item, condition) : false;\n      }\n      return match(get(item, key), condition);\n    });\n  }\n  return match;\n}\nfunction createOperators(match, operators = {}) {\n  return {\n    $match: (item, condition) => match(item, condition),\n    /**\n     * Match if item equals condition\n     **/\n    $eq: (item, condition) => condition instanceof RegExp ? condition.test(item) : item === condition,\n    /**\n     * Match if item not equals condition\n     **/\n    $ne: (item, condition) => condition instanceof RegExp ? !condition.test(item) : item !== condition,\n    /**\n     * Match is condition is false\n     **/\n    $not: (item, condition) => !match(item, condition),\n    /**\n     * Match only if all of nested conditions are true\n     **/\n    $and: (item, condition) => {\n      assertArray(condition, \"$and requires an array as condition\");\n      return condition.every((cond) => match(item, cond));\n    },\n    /**\n     * Match if any of nested conditions is true\n     **/\n    $or: (item, condition) => {\n      assertArray(condition, \"$or requires an array as condition\");\n      return condition.some((cond) => match(item, cond));\n    },\n    /**\n     * Match if item is in condition array\n     **/\n    $in: (item, condition) => ensureArray(condition).some(\n      (cond) => Array.isArray(item) ? match(item, { $contains: cond }) : match(item, cond)\n    ),\n    /**\n     * Match if item contains every condition or match every rule in condition array\n     **/\n    $contains: (item, condition) => {\n      item = Array.isArray(item) ? item : String(item);\n      return ensureArray(condition).every((i) => item.includes(i));\n    },\n    /**\n     * Ignore case contains\n     **/\n    $icontains: (item, condition) => {\n      if (typeof condition !== \"string\") {\n        throw new TypeError(\"$icontains requires a string, use $contains instead\");\n      }\n      item = String(item).toLocaleLowerCase();\n      return ensureArray(condition).every((i) => item.includes(i.toLocaleLowerCase()));\n    },\n    /**\n     * Match if item contains at least one rule from condition array\n     */\n    $containsAny: (item, condition) => {\n      assertArray(condition, \"$containsAny requires an array as condition\");\n      item = Array.isArray(item) ? item : String(item);\n      return condition.some((i) => item.includes(i));\n    },\n    /**\n     * Check key existence\n     */\n    $exists: (item, condition) => condition ? typeof item !== \"undefined\" : typeof item === \"undefined\",\n    /**\n     * Match if type of item equals condition\n     */\n    $type: (item, condition) => typeof item === String(condition),\n    /**\n     * Provides regular expression capabilities for pattern matching strings.\n     */\n    $regex: (item, condition) => {\n      if (!(condition instanceof RegExp)) {\n        const matched = String(condition).match(/\\/(.*)\\/([dgimsuy]*)$/);\n        condition = matched?.[1] ? new RegExp(matched[1], matched[2] || \"\") : new RegExp(condition);\n      }\n      return condition.test(String(item || \"\"));\n    },\n    /**\n     * Check if item is less than condition\n     */\n    $lt: (item, condition) => {\n      return item < condition;\n    },\n    /**\n     * Check if item is less than or equal to condition\n     */\n    $lte: (item, condition) => {\n      return item <= condition;\n    },\n    /**\n     * Check if item is greater than condition\n     */\n    $gt: (item, condition) => {\n      return item > condition;\n    },\n    /**\n     * Check if item is greater than or equal to condition\n     */\n    $gte: (item, condition) => {\n      return item >= condition;\n    },\n    ...operators || {}\n  };\n}\n","import { joinURL } from \"ufo\";\nimport { apply, ensureArray, sortList, withoutKeys, withKeys, omit } from \"./utils.js\";\nimport { createMatch } from \"./index.js\";\nexport function createPipelineFetcher(getContentsList) {\n  const match = createMatch();\n  const surround = (data, { query, before, after }) => {\n    const matchQuery = typeof query === \"string\" ? { _path: query } : query;\n    const index = data.findIndex((item) => match(item, matchQuery));\n    before = before ?? 1;\n    after = after ?? 1;\n    const slice = new Array(before + after).fill(null, 0);\n    return index === -1 ? slice : slice.map((_, i) => data[index - before + i + Number(i >= before)] || null);\n  };\n  const matchingPipelines = [\n    // Conditions\n    (state, params) => {\n      const filtered = state.result.filter((item) => ensureArray(params.where).every((matchQuery) => match(item, matchQuery)));\n      return {\n        ...state,\n        result: filtered,\n        total: filtered.length\n      };\n    },\n    // Sort data\n    (state, params) => ensureArray(params.sort).forEach((options) => sortList(state.result, options)),\n    function fetchSurround(state, params, db) {\n      if (params.surround) {\n        let _surround = surround(state.result?.length === 1 ? db : state.result, params.surround);\n        _surround = apply(withoutKeys(params.without))(_surround);\n        _surround = apply(withKeys(params.only))(_surround);\n        state.surround = _surround;\n      }\n      return state;\n    }\n  ];\n  const transformingPiples = [\n    // Skip first items\n    (state, params) => {\n      if (params.skip) {\n        return {\n          ...state,\n          result: state.result.slice(params.skip),\n          skip: params.skip\n        };\n      }\n    },\n    // Pick first items\n    (state, params) => {\n      if (params.limit) {\n        return {\n          ...state,\n          result: state.result.slice(0, params.limit),\n          limit: params.limit\n        };\n      }\n    },\n    function fetchDirConfig(state, params, db) {\n      if (params.dirConfig) {\n        const path = state.result[0]?._path || params.where?.find((w) => w._path)?._path;\n        if (typeof path === \"string\") {\n          const dirConfig = db.find((item) => item._path === joinURL(path, \"_dir\"));\n          if (dirConfig) {\n            state.dirConfig = { _path: dirConfig._path, ...withoutKeys([\"_\"])(dirConfig) };\n          }\n        }\n      }\n      return state;\n    },\n    // Remove unwanted fields\n    (state, params) => ({\n      ...state,\n      result: apply(withoutKeys(params.without))(state.result)\n    }),\n    // Select only wanted fields\n    (state, params) => ({\n      ...state,\n      result: apply(withKeys(params.only))(state.result)\n    })\n  ];\n  return async (query) => {\n    const db = await getContentsList();\n    const params = query.params();\n    const result1 = {\n      result: db,\n      limit: 0,\n      skip: 0,\n      total: db.length\n    };\n    const matchedData = matchingPipelines.reduce(($data, pipe) => pipe($data, params, db) || $data, result1);\n    if (params.count) {\n      return {\n        result: matchedData.result.length\n      };\n    }\n    const result = transformingPiples.reduce(($data, pipe) => pipe($data, params, db) || $data, matchedData);\n    if (params.first) {\n      return {\n        ...omit([\"skip\", \"limit\", \"total\"])(result),\n        result: result.result[0]\n      };\n    }\n    return result;\n  };\n}\n","import { createPipelineFetcher } from \"./pipeline.js\";\nexport function createPipelineFetcherLegacy(getContentsList) {\n  const _pipelineFetcher = createPipelineFetcher(getContentsList);\n  return async (query) => {\n    if (query.params().first) {\n      query.withDirConfig();\n    }\n    const params = query.params();\n    const result = await _pipelineFetcher(query);\n    if (params.surround) {\n      return result?.surround;\n    }\n    if (result?.dirConfig) {\n      result.result = {\n        _path: result.dirConfig?._path,\n        ...result.result,\n        _dir: result.dirConfig\n      };\n    }\n    return result?.result;\n  };\n}\n","import { pascalCase } from \"scule\";\nimport slugify from \"slugify\";\nimport { withoutTrailingSlash, withLeadingSlash } from \"ufo\";\nimport { defineTransformer } from \"./utils.js\";\nconst SEMVER_REGEX = /^(\\d+)(\\.\\d+)*(\\.x)?$/;\nexport const describeId = (id) => {\n  const [_source, ...parts] = id.split(\":\");\n  const [, basename, _extension] = parts[parts.length - 1]?.match(/(.*)\\.([^.]+)$/) || [];\n  if (basename) {\n    parts[parts.length - 1] = basename;\n  }\n  const _path = (parts || []).join(\"/\");\n  return {\n    _source,\n    _path,\n    _extension,\n    _file: _extension ? `${_path}.${_extension}` : _path,\n    _basename: basename || \"\"\n  };\n};\nexport default defineTransformer({\n  name: \"path-meta\",\n  extensions: [\".*\"],\n  transform(content, options = {}) {\n    const { locales = [], defaultLocale = \"en\", respectPathCase = false } = options;\n    const { _source, _file, _path, _extension, _basename } = describeId(content._id);\n    const parts = _path.split(\"/\");\n    const _locale = locales.includes(parts[0]) ? parts.shift() : defaultLocale;\n    const filePath = generatePath(parts.join(\"/\"), { respectPathCase });\n    return {\n      _path: filePath,\n      _dir: filePath.split(\"/\").slice(-2)[0],\n      _draft: content._draft || content.draft || isDraft(_path),\n      _partial: isPartial(_path),\n      _locale,\n      ...content,\n      // TODO: move title to Markdown parser\n      title: content.title || generateTitle(refineUrlPart(_basename)),\n      _source,\n      _file,\n      _stem: _path,\n      _extension\n    };\n  }\n});\nconst isDraft = (path) => !!path.match(/\\.draft(\\/|\\.|$)/);\nconst isPartial = (path) => path.split(/[:/]/).some((part) => part.match(/^_.*/));\nexport const generatePath = (path, { forceLeadingSlash = true, respectPathCase = false } = {}) => {\n  path = path.split(\"/\").map((part) => slugify(refineUrlPart(part), { lower: !respectPathCase })).join(\"/\");\n  return forceLeadingSlash ? withLeadingSlash(withoutTrailingSlash(path)) : path;\n};\nexport const generateTitle = (path) => path.split(/[\\s-]/g).map(pascalCase).join(\" \");\nexport function refineUrlPart(name) {\n  name = name.split(/[/:]/).pop();\n  if (SEMVER_REGEX.test(name)) {\n    return name;\n  }\n  return name.replace(/(\\d+\\.)?(.*)/, \"$2\").replace(/^index(\\.draft)?$/, \"\").replace(/\\.draft$/, \"\");\n}\n","import { generateTitle } from \"../transformers/path-meta.js\";\nimport { useRuntimeConfig } from \"#imports\";\nexport function createNav(contents, configs) {\n  const { navigation } = useRuntimeConfig().public.content;\n  if (navigation === false) {\n    return [];\n  }\n  const pickNavigationFields = (content) => ({\n    ...pick([\"title\", ...navigation.fields])(content),\n    ...isObject(content?.navigation) ? content.navigation : {}\n  });\n  const nav = contents.sort((a, b) => a._path.localeCompare(b._path)).reduce((nav2, content) => {\n    const parts = content._path.substring(1).split(\"/\");\n    const idParts = content._id.split(\":\").slice(1);\n    const isIndex = !!idParts[idParts.length - 1]?.match(/([1-9][0-9]*\\.)?index.md/g);\n    const getNavItem = (content2) => ({\n      title: content2.title,\n      _path: content2._path,\n      _file: content2._file,\n      children: [],\n      ...pickNavigationFields(content2),\n      ...content2._draft ? { _draft: true } : {}\n    });\n    const navItem = getNavItem(content);\n    if (isIndex) {\n      const dirConfig = configs[navItem._path];\n      if (typeof dirConfig?.navigation !== \"undefined\" && !dirConfig?.navigation) {\n        return nav2;\n      }\n      if (content._path !== \"/\") {\n        const indexItem = getNavItem(content);\n        navItem.children.push(indexItem);\n      }\n      if (dirConfig) {\n        Object.assign(\n          navItem,\n          pickNavigationFields(dirConfig)\n        );\n      }\n    }\n    if (parts.length === 1) {\n      nav2.push(navItem);\n      return nav2;\n    }\n    const siblings = parts.slice(0, -1).reduce((nodes, part, i) => {\n      const currentPathPart = \"/\" + parts.slice(0, i + 1).join(\"/\");\n      const conf = configs[currentPathPart];\n      if (typeof conf?.navigation !== \"undefined\" && !conf.navigation) {\n        return [];\n      }\n      let parent = nodes.find((n) => n._path === currentPathPart);\n      if (!parent) {\n        parent = {\n          title: generateTitle(part),\n          _path: currentPathPart,\n          _file: content._file,\n          children: [],\n          ...conf && pickNavigationFields(conf)\n        };\n        nodes.push(parent);\n      }\n      return parent.children;\n    }, nav2);\n    siblings.push(navItem);\n    return nav2;\n  }, []);\n  return sortAndClear(nav);\n}\nconst collator = new Intl.Collator(void 0, { numeric: true, sensitivity: \"base\" });\nfunction sortAndClear(nav) {\n  nav.forEach((item) => {\n    item._file = item._file.split(\".\").slice(0, -1).join(\".\");\n  });\n  const sorted = nav.sort((a, b) => collator.compare(a._file, b._file));\n  for (const item of sorted) {\n    if (item.children?.length) {\n      sortAndClear(item.children);\n    } else {\n      delete item.children;\n    }\n    delete item._file;\n  }\n  return nav;\n}\nfunction pick(keys) {\n  return (obj) => {\n    obj = obj || {};\n    if (keys && keys.length) {\n      return keys.filter((key) => typeof obj[key] !== \"undefined\").reduce((newObj, key) => Object.assign(newObj, { [key]: obj[key] }), {});\n    }\n    return obj;\n  };\n}\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\n","import memoryDriver from \"unstorage/drivers/memory\";\nimport { createStorage, prefixStorage } from \"unstorage\";\nimport { withBase } from \"ufo\";\nimport { createPipelineFetcherLegacy } from \"../../query/match/pipeline-legacy.js\";\nimport { createQuery } from \"../../query/query.js\";\nimport { createNav } from \"../../server/navigation.js\";\nimport { useContentPreview } from \"../../composables/preview.js\";\nimport { useRuntimeConfig, useNuxtApp } from \"#imports\";\nconst withContentBase = (url) => withBase(url, useRuntimeConfig().public.content.api.baseURL);\nexport const contentStorage = prefixStorage(createStorage({ driver: memoryDriver() }), \"@content\");\nexport function createDB(storage) {\n  async function getItems() {\n    const keys = new Set(await storage.getKeys(\"cache:\"));\n    const previewToken = useContentPreview().getPreviewToken();\n    if (previewToken) {\n      const previewMeta = await storage.getItem(`${previewToken}$`).then((data) => data || {});\n      if (Array.isArray(previewMeta.ignoreSources)) {\n        const sources = previewMeta.ignoreSources.map((s) => `cache:${s.trim()}:`);\n        for (const key of keys) {\n          if (sources.some((s) => key.startsWith(s))) {\n            keys.delete(key);\n          }\n        }\n      }\n      const previewKeys = await storage.getKeys(`${previewToken}:`);\n      const previewContents = await Promise.all(previewKeys.map((key) => storage.getItem(key)));\n      for (const pItem of previewContents) {\n        keys.delete(`cache:${pItem._id}`);\n        if (!pItem.__deleted) {\n          keys.add(`${previewToken}:${pItem._id}`);\n        }\n      }\n    }\n    const items = await Promise.all(Array.from(keys).map((key) => storage.getItem(key)));\n    return items;\n  }\n  return {\n    storage,\n    fetch: createPipelineFetcherLegacy(getItems),\n    query: (query) => createQuery(createPipelineFetcherLegacy(getItems), {\n      initialParams: query,\n      legacy: true\n    })\n  };\n}\nlet contentDatabase = null;\nlet contentDatabaseInitPromise = null;\nexport async function useContentDatabase() {\n  if (contentDatabaseInitPromise) {\n    await contentDatabaseInitPromise;\n  } else if (!contentDatabase) {\n    contentDatabaseInitPromise = initContentDatabase();\n    contentDatabase = await contentDatabaseInitPromise;\n  }\n  return contentDatabase;\n}\nasync function initContentDatabase() {\n  const nuxtApp = useNuxtApp();\n  const { content } = useRuntimeConfig().public;\n  const _contentDatabase = createDB(contentStorage);\n  const integrity = await _contentDatabase.storage.getItem(\"integrity\");\n  if (content.integrity !== +(integrity || 0)) {\n    const { contents, navigation } = await $fetch(withContentBase(content.integrity ? `cache.${content.integrity}.json` : \"cache.json\"));\n    await Promise.all(\n      contents.map((content2) => _contentDatabase.storage.setItem(`cache:${content2._id}`, content2))\n    );\n    await _contentDatabase.storage.setItem(\"navigation\", navigation);\n    await _contentDatabase.storage.setItem(\"integrity\", content.integrity);\n  }\n  await nuxtApp.callHook(\"content:storage\", _contentDatabase.storage);\n  return _contentDatabase;\n}\nexport async function generateNavigation(query) {\n  const db = await useContentDatabase();\n  if (!useContentPreview().getPreviewToken() && Object.keys(query || {}).length === 0) {\n    return db.storage.getItem(\"navigation\");\n  }\n  const contents = await db.query(query).where({\n    /**\n     * Partial contents are not included in the navigation\n     * A partial content is a content that has `_` prefix in its path\n     */\n    _partial: false,\n    /**\n    * Exclude any pages which have opted out of navigation via frontmatter.\n    */\n    navigation: {\n      $ne: false\n    }\n  }).find();\n  const dirConfigs = await db.query().where({ _path: /\\/_dir$/i, _partial: true }).find();\n  const configs = dirConfigs.reduce((configs2, conf) => {\n    if (conf.title?.toLowerCase() === \"dir\") {\n      conf.title = void 0;\n    }\n    const key = conf._path.split(\"/\").slice(0, -1).join(\"/\") || \"/\";\n    configs2[key] = {\n      ...conf,\n      // Extract meta from body. (non MD files)\n      ...conf.body\n    };\n    return configs2;\n  }, {});\n  return createNav(contents, configs);\n}\n"],"names":[],"mappings":"","x_google_ignoreList":[0,1,2,3,4,5]}