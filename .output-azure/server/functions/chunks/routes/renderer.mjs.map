{"version":3,"file":"renderer.mjs","sources":["../../../../../node_modules/@unhead/vue/dist/shared/vue.f49591ad.mjs","../../../../../node_modules/nuxt/dist/core/runtime/nitro/renderer.js"],"sourcesContent":["import { createServerHead as createServerHead$1, createHead as createHead$1, getActiveHead } from 'unhead';\nimport { version, unref, nextTick, inject } from 'vue';\nimport { defineHeadPlugin } from '@unhead/shared';\n\nconst Vue3 = version[0] === \"3\";\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref) {\n  if (ref instanceof Promise || ref instanceof Date || ref instanceof RegExp)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r));\n  if (typeof root === \"object\") {\n    const resolved = {};\n    for (const k in root) {\n      if (!Object.prototype.hasOwnProperty.call(root, k)) {\n        continue;\n      }\n      if (k === \"titleTemplate\" || k[0] === \"o\" && k[1] === \"n\") {\n        resolved[k] = unref(root[k]);\n        continue;\n      }\n      resolved[k] = resolveUnrefHeadInput(root[k]);\n    }\n    return resolved;\n  }\n  return root;\n}\n\nconst VueReactivityPlugin = defineHeadPlugin({\n  hooks: {\n    \"entries:resolve\": (ctx) => {\n      for (const entry of ctx.entries)\n        entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n    }\n  }\n});\n\nconst headSymbol = \"usehead\";\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.config.globalProperties.$head = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  return plugin.install;\n}\nfunction createServerHead(options = {}) {\n  const head = createServerHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\nfunction createHead(options = {}) {\n  options.domDelayFn = options.domDelayFn || ((fn) => nextTick(() => setTimeout(() => fn(), 0)));\n  const head = createHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__unhead_injection_handler__\";\nfunction setHeadInjectionHandler(handler) {\n  _global[globalKey] = handler;\n}\nfunction injectHead() {\n  if (globalKey in _global) {\n    return _global[globalKey]();\n  }\n  const head = inject(headSymbol);\n  if (!head && process.env.NODE_ENV !== \"production\")\n    console.warn(\"Unhead is missing Vue context, falling back to shared context. This may have unexpected results.\");\n  return head || getActiveHead();\n}\n\nexport { Vue3 as V, createServerHead as a, createHead as c, headSymbol as h, injectHead as i, resolveUnrefHeadInput as r, setHeadInjectionHandler as s };\n","import { AsyncLocalStorage } from \"node:async_hooks\";\nimport {\n  createRenderer,\n  getPrefetchLinks,\n  getPreloadLinks,\n  getRequestDependencies,\n  renderResourceHeaders\n} from \"vue-bundle-renderer/runtime\";\nimport { appendResponseHeader, createError, getQuery, getResponseStatus, getResponseStatusText, readBody, writeEarlyHints } from \"h3\";\nimport devalue from \"@nuxt/devalue\";\nimport { stringify, uneval } from \"devalue\";\nimport destr from \"destr\";\nimport { getQuery as getURLQuery, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { renderToString as _renderToString } from \"vue/server-renderer\";\nimport { propsToString, renderSSRHead } from \"@unhead/ssr\";\nimport { createServerHead, resolveUnrefHeadInput } from \"@unhead/vue\";\nimport { defineRenderHandler, getRouteRules, useRuntimeConfig, useStorage } from \"#internal/nitro\";\nimport { useNitroApp } from \"#internal/nitro/app\";\nimport unheadPlugins from \"#internal/unhead-plugins.mjs\";\nimport { renderSSRHeadOptions } from \"#internal/unhead.config.mjs\";\nimport { appHead, appId, appRootAttrs, appRootTag, appTeleportAttrs, appTeleportTag, componentIslands, multiApp } from \"#internal/nuxt.config.mjs\";\nimport { buildAssetsURL, publicAssetsURL } from \"#internal/nuxt/paths\";\nglobalThis.__buildAssetsURL = buildAssetsURL;\nglobalThis.__publicAssetsURL = publicAssetsURL;\nif (process.env.NUXT_ASYNC_CONTEXT && !(\"AsyncLocalStorage\" in globalThis)) {\n  globalThis.AsyncLocalStorage = AsyncLocalStorage;\n}\nconst getClientManifest = () => import(\"#build/dist/server/client.manifest.mjs\").then((r) => r.default || r).then((r) => typeof r === \"function\" ? r() : r);\nconst getEntryIds = () => getClientManifest().then((r) => Object.values(r).filter(\n  (r2) => (\n    // @ts-expect-error internal key set by CSS inlining configuration\n    r2._globalCSS\n  )\n).map((r2) => r2.src));\nconst getServerEntry = () => import(\"#build/dist/server/server.mjs\").then((r) => r.default || r);\nconst getSSRStyles = lazyCachedFunction(() => import(\"#build/dist/server/styles.mjs\").then((r) => r.default || r));\nconst getSSRRenderer = lazyCachedFunction(async () => {\n  const manifest = await getClientManifest();\n  if (!manifest) {\n    throw new Error(\"client.manifest is not available\");\n  }\n  const createSSRApp = await getServerEntry();\n  if (!createSSRApp) {\n    throw new Error(\"Server bundle is not available\");\n  }\n  const options = {\n    manifest,\n    renderToString,\n    buildAssetsURL\n  };\n  const renderer = createRenderer(createSSRApp, options);\n  async function renderToString(input, context) {\n    const html = await _renderToString(input, context);\n    if (import.meta.dev && process.env.NUXT_VITE_NODE_OPTIONS) {\n      renderer.rendererContext.updateManifest(await getClientManifest());\n    }\n    return APP_ROOT_OPEN_TAG + html + APP_ROOT_CLOSE_TAG;\n  }\n  return renderer;\n});\nconst getSPARenderer = lazyCachedFunction(async () => {\n  const manifest = await getClientManifest();\n  const spaTemplate = await import(\"#spa-template\").then((r) => r.template).catch(() => \"\").then((r) => APP_ROOT_OPEN_TAG + r + APP_ROOT_CLOSE_TAG);\n  const options = {\n    manifest,\n    renderToString: () => spaTemplate,\n    buildAssetsURL\n  };\n  const renderer = createRenderer(() => () => {\n  }, options);\n  const result = await renderer.renderToString({});\n  const renderToString = (ssrContext) => {\n    const config = useRuntimeConfig(ssrContext.event);\n    ssrContext.modules = ssrContext.modules || /* @__PURE__ */ new Set();\n    ssrContext.payload.serverRendered = false;\n    ssrContext.config = {\n      public: config.public,\n      app: config.app\n    };\n    return Promise.resolve(result);\n  };\n  return {\n    rendererContext: renderer.rendererContext,\n    renderToString\n  };\n});\nconst payloadCache = import.meta.prerender ? useStorage(\"internal:nuxt:prerender:payload\") : null;\nconst islandCache = import.meta.prerender ? useStorage(\"internal:nuxt:prerender:island\") : null;\nconst islandPropCache = import.meta.prerender ? useStorage(\"internal:nuxt:prerender:island-props\") : null;\nconst sharedPrerenderPromises = import.meta.prerender && process.env.NUXT_SHARED_DATA ? /* @__PURE__ */ new Map() : null;\nconst sharedPrerenderKeys = /* @__PURE__ */ new Set();\nconst sharedPrerenderCache = import.meta.prerender && process.env.NUXT_SHARED_DATA ? {\n  get(key) {\n    if (sharedPrerenderKeys.has(key)) {\n      return sharedPrerenderPromises.get(key) ?? useStorage(\"internal:nuxt:prerender:shared\").getItem(key);\n    }\n  },\n  async set(key, value) {\n    sharedPrerenderKeys.add(key);\n    sharedPrerenderPromises.set(key, value);\n    useStorage(\"internal:nuxt:prerender:shared\").setItem(key, await value).finally(() => sharedPrerenderPromises.delete(key));\n  }\n} : null;\nconst ISLAND_SUFFIX_RE = /\\.json(\\?.*)?$/;\nasync function getIslandContext(event) {\n  let url = event.path || \"\";\n  if (import.meta.prerender && event.path && await islandPropCache.hasItem(event.path)) {\n    url = await islandPropCache.getItem(event.path);\n  }\n  const componentParts = url.substring(\"/__nuxt_island\".length + 1).replace(ISLAND_SUFFIX_RE, \"\").split(\"_\");\n  const hashId = componentParts.length > 1 ? componentParts.pop() : void 0;\n  const componentName = componentParts.join(\"_\");\n  const context = event.method === \"GET\" ? getQuery(event) : await readBody(event);\n  const ctx = {\n    url: \"/\",\n    ...context,\n    id: hashId,\n    name: componentName,\n    props: destr(context.props) || {},\n    slots: {},\n    components: {}\n  };\n  return ctx;\n}\nconst HAS_APP_TELEPORTS = !!(appTeleportTag && appTeleportAttrs.id);\nconst APP_TELEPORT_OPEN_TAG = HAS_APP_TELEPORTS ? `<${appTeleportTag}${propsToString(appTeleportAttrs)}>` : \"\";\nconst APP_TELEPORT_CLOSE_TAG = HAS_APP_TELEPORTS ? `</${appTeleportTag}>` : \"\";\nconst APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;\nconst APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;\nconst PAYLOAD_URL_RE = process.env.NUXT_JSON_PAYLOADS ? /\\/_payload.json(\\?.*)?$/ : /\\/_payload.js(\\?.*)?$/;\nconst ROOT_NODE_REGEX = new RegExp(`^<${appRootTag}[^>]*>([\\\\s\\\\S]*)<\\\\/${appRootTag}>$`);\nconst PRERENDER_NO_SSR_ROUTES = /* @__PURE__ */ new Set([\"/index.html\", \"/200.html\", \"/404.html\"]);\nexport default defineRenderHandler(async (event) => {\n  const nitroApp = useNitroApp();\n  const ssrError = event.path.startsWith(\"/__nuxt_error\") ? getQuery(event) : null;\n  if (ssrError && ssrError.statusCode) {\n    ssrError.statusCode = Number.parseInt(ssrError.statusCode);\n  }\n  if (ssrError && !(\"__unenv__\" in event.node.req)) {\n    throw createError({\n      statusCode: 404,\n      statusMessage: \"Page Not Found: /__nuxt_error\"\n    });\n  }\n  const isRenderingIsland = componentIslands && event.path.startsWith(\"/__nuxt_island\");\n  const islandContext = isRenderingIsland ? await getIslandContext(event) : void 0;\n  if (import.meta.prerender && islandContext && event.path && await islandCache.hasItem(event.path)) {\n    return islandCache.getItem(event.path);\n  }\n  let url = ssrError?.url || islandContext?.url || event.path;\n  const isRenderingPayload = PAYLOAD_URL_RE.test(url) && !isRenderingIsland;\n  if (isRenderingPayload) {\n    url = url.substring(0, url.lastIndexOf(\"/\")) || \"/\";\n    event._path = url;\n    event.node.req.url = url;\n    if (import.meta.prerender && await payloadCache.hasItem(url)) {\n      return payloadCache.getItem(url);\n    }\n  }\n  const routeOptions = getRouteRules(event);\n  const head = createServerHead({\n    plugins: unheadPlugins\n  });\n  const headEntryOptions = { mode: \"server\" };\n  if (!isRenderingIsland) {\n    head.push(appHead, headEntryOptions);\n  }\n  const ssrContext = {\n    url,\n    event,\n    runtimeConfig: useRuntimeConfig(event),\n    noSSR: !!process.env.NUXT_NO_SSR || event.context.nuxt?.noSSR || routeOptions.ssr === false && !isRenderingIsland || (import.meta.prerender ? PRERENDER_NO_SSR_ROUTES.has(url) : false),\n    head,\n    error: !!ssrError,\n    nuxt: void 0,\n    /* NuxtApp */\n    payload: ssrError ? { error: ssrError } : {},\n    _payloadReducers: /* @__PURE__ */ Object.create(null),\n    modules: /* @__PURE__ */ new Set(),\n    islandContext\n  };\n  if (import.meta.prerender && process.env.NUXT_SHARED_DATA) {\n    ssrContext._sharedPrerenderCache = sharedPrerenderCache;\n  }\n  const _PAYLOAD_EXTRACTION = import.meta.prerender && process.env.NUXT_PAYLOAD_EXTRACTION && !ssrContext.noSSR && !isRenderingIsland;\n  const payloadURL = _PAYLOAD_EXTRACTION ? joinURL(ssrContext.runtimeConfig.app.cdnURL || ssrContext.runtimeConfig.app.baseURL, url, process.env.NUXT_JSON_PAYLOADS ? \"_payload.json\" : \"_payload.js\") + \"?\" + ssrContext.runtimeConfig.app.buildId : void 0;\n  if (import.meta.prerender) {\n    ssrContext.payload.prerenderedAt = Date.now();\n  }\n  const renderer = process.env.NUXT_NO_SSR || ssrContext.noSSR ? await getSPARenderer() : await getSSRRenderer();\n  if (process.env.NUXT_EARLY_HINTS && !isRenderingPayload && !import.meta.prerender) {\n    const { link } = renderResourceHeaders({}, renderer.rendererContext);\n    if (link) {\n      writeEarlyHints(event, link);\n    }\n  }\n  if (process.env.NUXT_INLINE_STYLES && !isRenderingIsland) {\n    for (const id of await getEntryIds()) {\n      ssrContext.modules.add(id);\n    }\n  }\n  const _rendered = await renderer.renderToString(ssrContext).catch(async (error) => {\n    if (ssrContext._renderResponse && error.message === \"skipping render\") {\n      return {};\n    }\n    const _err = !ssrError && ssrContext.payload?.error || error;\n    await ssrContext.nuxt?.hooks.callHook(\"app:error\", _err);\n    throw _err;\n  });\n  await ssrContext.nuxt?.hooks.callHook(\"app:rendered\", { ssrContext, renderResult: _rendered });\n  if (ssrContext._renderResponse) {\n    return ssrContext._renderResponse;\n  }\n  if (ssrContext.payload?.error && !ssrError) {\n    throw ssrContext.payload.error;\n  }\n  if (isRenderingPayload) {\n    const response2 = renderPayloadResponse(ssrContext);\n    if (import.meta.prerender) {\n      await payloadCache.setItem(url, response2);\n    }\n    return response2;\n  }\n  if (_PAYLOAD_EXTRACTION) {\n    appendResponseHeader(event, \"x-nitro-prerender\", joinURL(url, process.env.NUXT_JSON_PAYLOADS ? \"_payload.json\" : \"_payload.js\"));\n    await payloadCache.setItem(withoutTrailingSlash(url), renderPayloadResponse(ssrContext));\n  }\n  const inlinedStyles = process.env.NUXT_INLINE_STYLES || isRenderingIsland ? await renderInlineStyles(ssrContext.modules ?? []) : [];\n  const NO_SCRIPTS = process.env.NUXT_NO_SCRIPTS || routeOptions.experimentalNoScripts;\n  const { styles, scripts } = getRequestDependencies(ssrContext, renderer.rendererContext);\n  if (_PAYLOAD_EXTRACTION && !NO_SCRIPTS && !isRenderingIsland) {\n    head.push({\n      link: [\n        process.env.NUXT_JSON_PAYLOADS ? { rel: \"preload\", as: \"fetch\", crossorigin: \"anonymous\", href: payloadURL } : { rel: \"modulepreload\", crossorigin: \"\", href: payloadURL }\n      ]\n    }, headEntryOptions);\n  }\n  if (inlinedStyles.length) {\n    head.push({ style: inlinedStyles });\n  }\n  if (!isRenderingIsland || import.meta.dev) {\n    const link = [];\n    for (const resource of Object.values(styles)) {\n      if (import.meta.dev && \"inline\" in getURLQuery(resource.file)) {\n        continue;\n      }\n      if (!import.meta.dev || !isRenderingIsland || resource.file.includes(\"scoped\") && !resource.file.includes(\"pages/\")) {\n        link.push({ rel: \"stylesheet\", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: \"\" });\n      }\n    }\n    if (link.length) {\n      head.push({ link }, headEntryOptions);\n    }\n  }\n  if (!NO_SCRIPTS && !isRenderingIsland) {\n    head.push({\n      link: getPreloadLinks(ssrContext, renderer.rendererContext)\n    }, headEntryOptions);\n    head.push({\n      link: getPrefetchLinks(ssrContext, renderer.rendererContext)\n    }, headEntryOptions);\n    head.push({\n      script: _PAYLOAD_EXTRACTION ? process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : renderPayloadScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL }) : process.env.NUXT_JSON_PAYLOADS ? renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) : renderPayloadScript({ ssrContext, data: ssrContext.payload })\n    }, {\n      ...headEntryOptions,\n      // this should come before another end of body scripts\n      tagPosition: \"bodyClose\",\n      tagPriority: \"high\"\n    });\n  }\n  if (!routeOptions.experimentalNoScripts && !isRenderingIsland) {\n    head.push({\n      script: Object.values(scripts).map((resource) => ({\n        type: resource.module ? \"module\" : null,\n        src: renderer.rendererContext.buildAssetsURL(resource.file),\n        defer: resource.module ? null : true,\n        // if we are rendering script tag payloads that import an async payload\n        // we need to ensure this resolves before executing the Nuxt entry\n        tagPosition: _PAYLOAD_EXTRACTION && !process.env.NUXT_JSON_PAYLOADS ? \"bodyClose\" : \"head\",\n        crossorigin: \"\"\n      }))\n    }, headEntryOptions);\n  }\n  const { headTags, bodyTags, bodyTagsOpen, htmlAttrs, bodyAttrs } = await renderSSRHead(head, renderSSRHeadOptions);\n  const htmlContext = {\n    island: isRenderingIsland,\n    htmlAttrs: htmlAttrs ? [htmlAttrs] : [],\n    head: normalizeChunks([headTags]),\n    bodyAttrs: bodyAttrs ? [bodyAttrs] : [],\n    bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),\n    body: [\n      componentIslands ? replaceIslandTeleports(ssrContext, _rendered.html) : _rendered.html,\n      APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : \"\") + APP_TELEPORT_CLOSE_TAG\n    ],\n    bodyAppend: [bodyTags]\n  };\n  await nitroApp.hooks.callHook(\"render:html\", htmlContext, { event });\n  if (isRenderingIsland && islandContext) {\n    const islandHead = {};\n    for (const entry of head.headEntries()) {\n      for (const [key, value] of Object.entries(resolveUnrefHeadInput(entry.input))) {\n        const currentValue = islandHead[key];\n        if (Array.isArray(currentValue)) {\n          currentValue.push(...value);\n        }\n        islandHead[key] = value;\n      }\n    }\n    islandHead.link = islandHead.link || [];\n    islandHead.style = islandHead.style || [];\n    const islandResponse = {\n      id: islandContext.id,\n      head: islandHead,\n      html: getServerComponentHTML(htmlContext.body),\n      components: getClientIslandResponse(ssrContext),\n      slots: getSlotIslandResponse(ssrContext)\n    };\n    await nitroApp.hooks.callHook(\"render:island\", islandResponse, { event, islandContext });\n    const response2 = {\n      body: JSON.stringify(islandResponse, null, 2),\n      statusCode: getResponseStatus(event),\n      statusMessage: getResponseStatusText(event),\n      headers: {\n        \"content-type\": \"application/json;charset=utf-8\",\n        \"x-powered-by\": \"Nuxt\"\n      }\n    };\n    if (import.meta.prerender) {\n      await islandCache.setItem(`/__nuxt_island/${islandContext.name}_${islandContext.id}.json`, response2);\n      await islandPropCache.setItem(`/__nuxt_island/${islandContext.name}_${islandContext.id}.json`, event.path);\n    }\n    return response2;\n  }\n  const response = {\n    body: renderHTMLDocument(htmlContext),\n    statusCode: getResponseStatus(event),\n    statusMessage: getResponseStatusText(event),\n    headers: {\n      \"content-type\": \"text/html;charset=utf-8\",\n      \"x-powered-by\": \"Nuxt\"\n    }\n  };\n  return response;\n});\nfunction lazyCachedFunction(fn) {\n  let res = null;\n  return () => {\n    if (res === null) {\n      res = fn().catch((err) => {\n        res = null;\n        throw err;\n      });\n    }\n    return res;\n  };\n}\nfunction normalizeChunks(chunks) {\n  return chunks.filter(Boolean).map((i) => i.trim());\n}\nfunction joinTags(tags) {\n  return tags.join(\"\");\n}\nfunction joinAttrs(chunks) {\n  if (chunks.length === 0) {\n    return \"\";\n  }\n  return \" \" + chunks.join(\" \");\n}\nfunction renderHTMLDocument(html) {\n  return `<!DOCTYPE html><html${joinAttrs(html.htmlAttrs)}><head>${joinTags(html.head)}</head><body${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPrepend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body></html>`;\n}\nasync function renderInlineStyles(usedModules) {\n  const styleMap = await getSSRStyles();\n  const inlinedStyles = /* @__PURE__ */ new Set();\n  for (const mod of usedModules) {\n    if (mod in styleMap && styleMap[mod]) {\n      for (const style of await styleMap[mod]()) {\n        inlinedStyles.add(style);\n      }\n    }\n  }\n  return Array.from(inlinedStyles).map((style) => ({ innerHTML: style }));\n}\nfunction renderPayloadResponse(ssrContext) {\n  return {\n    body: process.env.NUXT_JSON_PAYLOADS ? stringify(splitPayload(ssrContext).payload, ssrContext._payloadReducers) : `export default ${devalue(splitPayload(ssrContext).payload)}`,\n    statusCode: getResponseStatus(ssrContext.event),\n    statusMessage: getResponseStatusText(ssrContext.event),\n    headers: {\n      \"content-type\": process.env.NUXT_JSON_PAYLOADS ? \"application/json;charset=utf-8\" : \"text/javascript;charset=utf-8\",\n      \"x-powered-by\": \"Nuxt\"\n    }\n  };\n}\nfunction renderPayloadJsonScript(opts) {\n  const contents = opts.data ? stringify(opts.data, opts.ssrContext._payloadReducers) : \"\";\n  const payload = {\n    \"type\": \"application/json\",\n    \"innerHTML\": contents,\n    \"data-nuxt-data\": appId,\n    \"data-ssr\": !(process.env.NUXT_NO_SSR || opts.ssrContext.noSSR)\n  };\n  if (!multiApp) {\n    payload.id = \"__NUXT_DATA__\";\n  }\n  if (opts.src) {\n    payload[\"data-src\"] = opts.src;\n  }\n  const config = uneval(opts.ssrContext.config);\n  return [\n    payload,\n    {\n      innerHTML: multiApp ? `window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]={config:${config}}` : `window.__NUXT__={};window.__NUXT__.config=${config}`\n    }\n  ];\n}\nfunction renderPayloadScript(opts) {\n  opts.data.config = opts.ssrContext.config;\n  const _PAYLOAD_EXTRACTION = import.meta.prerender && process.env.NUXT_PAYLOAD_EXTRACTION && !opts.ssrContext.noSSR;\n  const nuxtData = devalue(opts.data);\n  if (_PAYLOAD_EXTRACTION) {\n    const singleAppPayload2 = `import p from \"${opts.src}\";window.__NUXT__={...p,...(${nuxtData})}`;\n    const multiAppPayload2 = `import p from \"${opts.src}\";window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]={...p,...(${nuxtData})}`;\n    return [\n      {\n        type: \"module\",\n        innerHTML: multiApp ? multiAppPayload2 : singleAppPayload2\n      }\n    ];\n  }\n  const singleAppPayload = `window.__NUXT__=${nuxtData}`;\n  const multiAppPayload = `window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]=${nuxtData}`;\n  return [\n    {\n      innerHTML: multiApp ? multiAppPayload : singleAppPayload\n    }\n  ];\n}\nfunction splitPayload(ssrContext) {\n  const { data, prerenderedAt, ...initial } = ssrContext.payload;\n  return {\n    initial: { ...initial, prerenderedAt },\n    payload: { data, prerenderedAt }\n  };\n}\nfunction getServerComponentHTML(body) {\n  const match = body[0].match(ROOT_NODE_REGEX);\n  return match?.[1] || body[0];\n}\nconst SSR_SLOT_TELEPORT_MARKER = /^uid=([^;]*);slot=(.*)$/;\nconst SSR_CLIENT_TELEPORT_MARKER = /^uid=([^;]*);client=(.*)$/;\nconst SSR_CLIENT_SLOT_MARKER = /^island-slot=[^;]*;(.*)$/;\nfunction getSlotIslandResponse(ssrContext) {\n  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.slots).length) {\n    return void 0;\n  }\n  const response = {};\n  for (const [name, slot] of Object.entries(ssrContext.islandContext.slots)) {\n    response[name] = {\n      ...slot,\n      fallback: ssrContext.teleports?.[`island-fallback=${name}`]\n    };\n  }\n  return response;\n}\nfunction getClientIslandResponse(ssrContext) {\n  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.components).length) {\n    return void 0;\n  }\n  const response = {};\n  for (const [clientUid, component] of Object.entries(ssrContext.islandContext.components)) {\n    const html = ssrContext.teleports?.[clientUid]?.replaceAll(\"<!--teleport start anchor-->\", \"\") || \"\";\n    response[clientUid] = {\n      ...component,\n      html,\n      slots: getComponentSlotTeleport(ssrContext.teleports ?? {})\n    };\n  }\n  return response;\n}\nfunction getComponentSlotTeleport(teleports) {\n  const entries = Object.entries(teleports);\n  const slots = {};\n  for (const [key, value] of entries) {\n    const match = key.match(SSR_CLIENT_SLOT_MARKER);\n    if (match) {\n      const [, slot] = match;\n      if (!slot) {\n        continue;\n      }\n      slots[slot] = value;\n    }\n  }\n  return slots;\n}\nfunction replaceIslandTeleports(ssrContext, html) {\n  const { teleports, islandContext } = ssrContext;\n  if (islandContext || !teleports) {\n    return html;\n  }\n  for (const key in teleports) {\n    const matchClientComp = key.match(SSR_CLIENT_TELEPORT_MARKER);\n    if (matchClientComp) {\n      const [, uid, clientId] = matchClientComp;\n      if (!uid || !clientId) {\n        continue;\n      }\n      html = html.replace(new RegExp(` data-island-uid=\"${uid}\" data-island-component=\"${clientId}\"[^>]*>`), (full) => {\n        return full + teleports[key];\n      });\n      continue;\n    }\n    const matchSlot = key.match(SSR_SLOT_TELEPORT_MARKER);\n    if (matchSlot) {\n      const [, uid, slot] = matchSlot;\n      if (!uid || !slot) {\n        continue;\n      }\n      html = html.replace(new RegExp(` data-island-uid=\"${uid}\" data-island-slot=\"${slot}\"[^>]*>`), (full) => {\n        return full + teleports[key];\n      });\n    }\n  }\n  return html;\n}\n"],"names":["renderToString","_renderToString"],"mappings":"","x_google_ignoreList":[0,1]}