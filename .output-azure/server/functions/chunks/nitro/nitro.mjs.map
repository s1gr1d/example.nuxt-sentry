{"version":3,"file":"nitro.mjs","sources":["../../../../../node_modules/destr/dist/index.mjs","../../../../../node_modules/ufo/dist/index.mjs","../../../../../node_modules/cookie-es/dist/index.mjs","../../../../../node_modules/ohash/dist/index.mjs","../../../../../node_modules/radix3/dist/index.mjs","../../../../../node_modules/defu/dist/defu.mjs","../../../../../node_modules/unenv/runtime/_internal/utils.mjs","../../../../../node_modules/unenv/runtime/node/events/_events.mjs","../../../../../node_modules/unenv/runtime/node/events/index.mjs","../../../../../node_modules/unenv/runtime/node/stream/readable.mjs","../../../../../node_modules/unenv/runtime/node/stream/writable.mjs","../../../../../node_modules/unenv/runtime/node/stream/duplex.mjs","../../../../../node_modules/unenv/runtime/node/net/socket.mjs","../../../../../node_modules/unenv/runtime/node/http/_request.mjs","../../../../../node_modules/unenv/runtime/node/http/_response.mjs","../../../../../node_modules/h3/dist/index.mjs","../../../../../node_modules/hookable/dist/index.mjs","../../../../../node_modules/node-fetch-native/dist/native.mjs","../../../../../node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs","../../../../../node_modules/ofetch/dist/node.mjs","../../../../../node_modules/unenv/runtime/fetch/call.mjs","../../../../../node_modules/unenv/runtime/fetch/index.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/utils.mjs","../../../../../node_modules/nuxt/dist/core/runtime/nitro/error.js","../../../../../node_modules/@sentry/nuxt/build/module/runtime/utils.js","../../../../../node_modules/@sentry/nuxt/build/module/runtime/plugins/sentry.server.js","../../../../../node_modules/nitropack/dist/runtime/internal/plugin.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/debug.mjs","../../../../../server/middleware/new-middleware.ts","../../../../../server/middleware/some-middleware.ts","../../../../../node_modules/klona/dist/index.mjs","../../../../../node_modules/scule/dist/index.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/utils.env.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/config.mjs","../../../../../node_modules/unstorage/dist/shared/unstorage.d569726e.mjs","../../../../../node_modules/unstorage/dist/index.mjs","../../../../../node_modules/unstorage/drivers/utils/index.mjs","../../../../../node_modules/unstorage/drivers/utils/node-fs.mjs","../../../../../node_modules/unstorage/drivers/fs-lite.mjs","../../../../../node_modules/unstorage/drivers/overlay.mjs","../../../../../node_modules/unstorage/drivers/memory.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/storage.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/cache.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/renderer.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/route-rules.mjs","../../../../../node_modules/unctx/dist/index.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/context.mjs","../../../../../node_modules/nuxt/dist/core/runtime/nitro/paths.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/utils/node.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/utils/plugins.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/emphasis.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/utils.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/code.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/html.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/link.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/list.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/utils/html-tags-list.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/paragraph.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/image.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/strong.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/inlineCode.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/containerComponent.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/handlers/index.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/options.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/utils/ast.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/toc.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/utils/props.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/compiler.js","../../../../../node_modules/@nuxtjs/mdc/dist/runtime/parser/index.js","../../../../../node_modules/@nuxt/content/dist/runtime/server/api/query.js","../../../../../node_modules/@nuxt/content/dist/runtime/server/api/cache.js","../../../../../node_modules/@nuxt/content/dist/runtime/server/preview.js","../../../../../node_modules/@nuxt/content/dist/runtime/server/api/navigation.js","../../../../../node_modules/nitropack/dist/runtime/internal/app.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/utils.lambda.mjs","../../../../../node_modules/nitropack/dist/runtime/internal/utils.azure.mjs","../../../../../node_modules/nitropack/dist/presets/azure/runtime/azure-swa.mjs"],"sourcesContent":["const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _value = value.trim();\n  if (\n    // eslint-disable-next-line unicorn/prefer-at\n    value[0] === '\"' && value.endsWith('\"') && !value.includes(\"\\\\\")\n  ) {\n    return _value.slice(1, -1);\n  }\n  if (_value.length <= 9) {\n    const _lval = _value.toLowerCase();\n    if (_lval === \"true\") {\n      return true;\n    }\n    if (_lval === \"false\") {\n      return false;\n    }\n    if (_lval === \"undefined\") {\n      return void 0;\n    }\n    if (_lval === \"null\") {\n      return null;\n    }\n    if (_lval === \"nan\") {\n      return Number.NaN;\n    }\n    if (_lval === \"infinity\") {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (_lval === \"-infinity\") {\n      return Number.NEGATIVE_INFINITY;\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\").replace(SLASH_RE, \"%2F\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  const cleanPath = s0.endsWith(\"/\") ? s0.slice(0, -1) : s0;\n  return (cleanPath || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction joinRelativeURL(..._input) {\n  const JOIN_SEGMENT_SPLIT_RE = /\\/(?!\\/)/;\n  const input = _input.filter(Boolean);\n  const segments = [];\n  let segmentsDepth = 0;\n  for (const i of input) {\n    if (!i || i === \"/\") {\n      continue;\n    }\n    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {\n      if (!s || s === \".\") {\n        continue;\n      }\n      if (s === \"..\") {\n        if (segments.length === 1 && hasProtocol(segments[0])) {\n          continue;\n        }\n        segments.pop();\n        segmentsDepth--;\n        continue;\n      }\n      if (sindex === 1 && segments[segments.length - 1]?.endsWith(\":/\")) {\n        segments[segments.length - 1] += \"/\" + s;\n        continue;\n      }\n      segments.push(s);\n      segmentsDepth++;\n    }\n  }\n  let url = segments.join(\"/\");\n  if (segmentsDepth >= 0) {\n    if (input[0]?.startsWith(\"/\") && !url.startsWith(\"/\")) {\n      url = \"/\" + url;\n    } else if (input[0]?.startsWith(\"./\") && !url.startsWith(\"./\")) {\n      url = \"./\" + url;\n    }\n  } else {\n    url = \"../\".repeat(-1 * segmentsDepth) + url;\n  }\n  if (input[input.length - 1]?.endsWith(\"/\") && !url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  let match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    match = input.match(/^\\/{2,}/);\n  }\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction normalizeURL(input) {\n  const parsed = parseURL(input);\n  parsed.pathname = encodePath(decodePath(parsed.pathname));\n  parsed.hash = encodeHash(decode(parsed.hash));\n  parsed.host = encodeHost(decode(parsed.host));\n  parsed.search = stringifyQuery(parseQuery(parsed.search));\n  return stringifyParsedURL(parsed);\n}\nfunction resolveURL(base = \"\", ...inputs) {\n  if (typeof base !== \"string\") {\n    throw new TypeError(\n      `URL input should be string received ${typeof base} (${base})`\n    );\n  }\n  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));\n  if (filteredInputs.length === 0) {\n    return base;\n  }\n  const url = parseURL(base);\n  for (const inputSegment of filteredInputs) {\n    const urlSegment = parseURL(inputSegment);\n    if (urlSegment.pathname) {\n      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);\n    }\n    if (urlSegment.hash && urlSegment.hash !== \"#\") {\n      url.hash = urlSegment.hash;\n    }\n    if (urlSegment.search && urlSegment.search !== \"?\") {\n      if (url.search && url.search !== \"?\") {\n        const queryString = stringifyQuery({\n          ...parseQuery(url.search),\n          ...parseQuery(urlSegment.search)\n        });\n        url.search = queryString.length > 0 ? \"?\" + queryString : \"\";\n      } else {\n        url.search = urlSegment.search;\n      }\n    }\n  }\n  return stringifyParsedURL(url);\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\nfunction withFragment(input, hash) {\n  if (!hash || hash === \"#\") {\n    return input;\n  }\n  const parsed = parseURL(input);\n  parsed.hash = hash === \"\" ? \"\" : \"#\" + encodeHash(hash);\n  return stringifyParsedURL(parsed);\n}\nfunction withoutFragment(input) {\n  return stringifyParsedURL({ ...parseURL(input), hash: \"\" });\n}\nfunction withoutHost(input) {\n  const parsed = parseURL(input);\n  return (parsed.pathname || \"/\") + parsed.search + parsed.hash;\n}\n\nconst protocolRelative = Symbol.for(\"ufo:protocolRelative\");\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  let [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  if (protocol === \"file:\") {\n    path = path.replace(/\\/(?=[A-Za-z]:)/, \"\");\n  }\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash,\n    [protocolRelative]: !protocol\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || \"\") + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", { strict }) {\n  const { pathname } = parseURL(input);\n  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass $URL {\n  constructor(input = \"\") {\n    __publicField(this, \"protocol\");\n    __publicField(this, \"host\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"pathname\");\n    __publicField(this, \"query\", {});\n    __publicField(this, \"hash\");\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryKey, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, isScriptProtocol, joinRelativeURL, joinURL, normalizeURL, parseAuth, parseFilename, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withFragment, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutFragment, withoutHost, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","function parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const obj = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (opt?.filter && !opt?.filter(key)) {\n      index = endIdx + 1;\n      continue;\n    }\n    if (void 0 === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\nfunction decode(str) {\n  return str.includes(\"%\") ? decodeURIComponent(str) : str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch {\n    return str;\n  }\n}\n\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/;\nfunction serialize(name, value, options) {\n  const opt = options || {};\n  const enc = opt.encode || encodeURIComponent;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  const encodedValue = enc(value);\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  let str = name + \"=\" + encodedValue;\n  if (void 0 !== opt.maxAge && opt.maxAge !== null) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (!isDate(opt.expires) || Number.isNaN(opt.expires.valueOf())) {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.priority) {\n    const priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n    switch (priority) {\n      case \"low\": {\n        str += \"; Priority=Low\";\n        break;\n      }\n      case \"medium\": {\n        str += \"; Priority=Medium\";\n        break;\n      }\n      case \"high\": {\n        str += \"; Priority=High\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option priority is invalid\");\n      }\n    }\n  }\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true: {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"lax\": {\n        str += \"; SameSite=Lax\";\n        break;\n      }\n      case \"strict\": {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"none\": {\n        str += \"; SameSite=None\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option sameSite is invalid\");\n      }\n    }\n  }\n  if (opt.partitioned) {\n    str += \"; Partitioned\";\n  }\n  return str;\n}\nfunction isDate(val) {\n  return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n\nfunction parseSetCookie(setCookieValue, options) {\n  const parts = (setCookieValue || \"\").split(\";\").filter((str) => typeof str === \"string\" && !!str.trim());\n  const nameValuePairStr = parts.shift() || \"\";\n  const parsed = _parseNameValuePair(nameValuePairStr);\n  const name = parsed.name;\n  let value = parsed.value;\n  try {\n    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);\n  } catch {\n  }\n  const cookie = {\n    name,\n    value\n  };\n  for (const part of parts) {\n    const sides = part.split(\"=\");\n    const partKey = (sides.shift() || \"\").trimStart().toLowerCase();\n    const partValue = sides.join(\"=\");\n    switch (partKey) {\n      case \"expires\": {\n        cookie.expires = new Date(partValue);\n        break;\n      }\n      case \"max-age\": {\n        cookie.maxAge = Number.parseInt(partValue, 10);\n        break;\n      }\n      case \"secure\": {\n        cookie.secure = true;\n        break;\n      }\n      case \"httponly\": {\n        cookie.httpOnly = true;\n        break;\n      }\n      case \"samesite\": {\n        cookie.sameSite = partValue;\n        break;\n      }\n      default: {\n        cookie[partKey] = partValue;\n      }\n    }\n  }\n  return cookie;\n}\nfunction _parseNameValuePair(nameValuePairStr) {\n  let name = \"\";\n  let value = \"\";\n  const nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\");\n  } else {\n    value = nameValuePairStr;\n  }\n  return { name, value };\n}\n\nfunction splitSetCookieString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitSetCookieString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nexport { parse, parseSetCookie, serialize, splitSetCookieString };\n","const defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass WordArray {\n  constructor(words, sigBytes) {\n    __publicField$1(this, \"words\");\n    __publicField$1(this, \"sigBytes\");\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    __publicField$1(this, \"_data\", new WordArray());\n    __publicField$1(this, \"_nDataBytes\", 0);\n    __publicField$1(this, \"_minBufferSize\", 0);\n    __publicField$1(this, \"blockSize\", 512 / 32);\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_hash\", new WordArray([...H]));\n  }\n  /**\n   * Resets the internal state of the hash object to initial values.\n   */\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  /**\n   * Finishes the hash calculation and returns the hash as a WordArray.\n   *\n   * @param {string} messageUpdate - Additional message content to include in the hash.\n   * @returns {WordArray} The finalised hash as a WordArray.\n   */\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3: {\n      k1 ^= (key[i + 2] & 255) << 16;\n    }\n    case 2: {\n      k1 ^= (key[i + 1] & 255) << 8;\n    }\n    case 1: {\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n    }\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nfunction diff(obj1, obj2, opts = {}) {\n  const h1 = _toHashedObject(obj1, opts);\n  const h2 = _toHashedObject(obj2, opts);\n  return _diff(h1, h2, opts);\n}\nfunction _diff(h1, h2, opts = {}) {\n  const diffs = [];\n  const allProps = /* @__PURE__ */ new Set([\n    ...Object.keys(h1.props || {}),\n    ...Object.keys(h2.props || {})\n  ]);\n  if (h1.props && h2.props) {\n    for (const prop of allProps) {\n      const p1 = h1.props[prop];\n      const p2 = h2.props[prop];\n      if (p1 && p2) {\n        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));\n      } else if (p1 || p2) {\n        diffs.push(\n          new DiffEntry((p2 || p1).key, p1 ? \"removed\" : \"added\", p2, p1)\n        );\n      }\n    }\n  }\n  if (allProps.size === 0 && h1.hash !== h2.hash) {\n    diffs.push(new DiffEntry((h2 || h1).key, \"changed\", h2, h1));\n  }\n  return diffs;\n}\nfunction _toHashedObject(obj, opts, key = \"\") {\n  if (obj && typeof obj !== \"object\") {\n    return new DiffHashedObject(key, obj, objectHash(obj, opts));\n  }\n  const props = {};\n  const hashes = [];\n  for (const _key in obj) {\n    props[_key] = _toHashedObject(\n      obj[_key],\n      opts,\n      key ? `${key}.${_key}` : _key\n    );\n    hashes.push(props[_key].hash);\n  }\n  return new DiffHashedObject(key, obj, `{${hashes.join(\":\")}}`, props);\n}\nclass DiffEntry {\n  constructor(key, type, newValue, oldValue) {\n    this.key = key;\n    this.type = type;\n    this.newValue = newValue;\n    this.oldValue = oldValue;\n  }\n  toString() {\n    return this.toJSON();\n  }\n  toJSON() {\n    switch (this.type) {\n      case \"added\": {\n        return `Added   \\`${this.key}\\``;\n      }\n      case \"removed\": {\n        return `Removed \\`${this.key}\\``;\n      }\n      case \"changed\": {\n        return `Changed \\`${this.key}\\` from \\`${this.oldValue?.toString() || \"-\"}\\` to \\`${this.newValue.toString()}\\``;\n      }\n    }\n  }\n}\nclass DiffHashedObject {\n  constructor(key, value, hash, props) {\n    this.key = key;\n    this.value = value;\n    this.hash = hash;\n    this.props = props;\n  }\n  toString() {\n    if (this.props) {\n      return `{${Object.keys(this.props).join(\",\")}}`;\n    } else {\n      return JSON.stringify(this.value);\n    }\n  }\n  toJSON() {\n    const k = this.key || \".\";\n    if (this.props) {\n      return `${k}({${Object.keys(this.props).join(\",\")}})`;\n    }\n    return `${k}(${this.value})`;\n  }\n}\n\nexport { diff, hash, isEqual, murmurHash, objectHash, sha256, sha256base64 };\n","const NODE_TYPES = {\n  NORMAL: 0,\n  WILDCARD: 1,\n  PLACEHOLDER: 2\n};\n\nfunction createRouter(options = {}) {\n  const ctx = {\n    options,\n    rootNode: createRadixNode(),\n    staticRoutesMap: {}\n  };\n  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\\/$/, \"\") || \"/\";\n  if (options.routes) {\n    for (const path in options.routes) {\n      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);\n    }\n  }\n  return {\n    ctx,\n    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),\n    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),\n    remove: (path) => remove(ctx, normalizeTrailingSlash(path))\n  };\n}\nfunction lookup(ctx, path) {\n  const staticPathNode = ctx.staticRoutesMap[path];\n  if (staticPathNode) {\n    return staticPathNode.data;\n  }\n  const sections = path.split(\"/\");\n  const params = {};\n  let paramsFound = false;\n  let wildcardNode = null;\n  let node = ctx.rootNode;\n  let wildCardParam = null;\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i];\n    if (node.wildcardChildNode !== null) {\n      wildcardNode = node.wildcardChildNode;\n      wildCardParam = sections.slice(i).join(\"/\");\n    }\n    const nextNode = node.children.get(section);\n    if (nextNode === void 0) {\n      if (node && node.placeholderChildren.length > 1) {\n        const remaining = sections.length - i;\n        node = node.placeholderChildren.find((c) => c.maxDepth === remaining) || null;\n      } else {\n        node = node.placeholderChildren[0] || null;\n      }\n      if (!node) {\n        break;\n      }\n      if (node.paramName) {\n        params[node.paramName] = section;\n      }\n      paramsFound = true;\n    } else {\n      node = nextNode;\n    }\n  }\n  if ((node === null || node.data === null) && wildcardNode !== null) {\n    node = wildcardNode;\n    params[node.paramName || \"_\"] = wildCardParam;\n    paramsFound = true;\n  }\n  if (!node) {\n    return null;\n  }\n  if (paramsFound) {\n    return {\n      ...node.data,\n      params: paramsFound ? params : void 0\n    };\n  }\n  return node.data;\n}\nfunction insert(ctx, path, data) {\n  let isStaticRoute = true;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  let _unnamedPlaceholderCtr = 0;\n  const matchedNodes = [node];\n  for (const section of sections) {\n    let childNode;\n    if (childNode = node.children.get(section)) {\n      node = childNode;\n    } else {\n      const type = getNodeType(section);\n      childNode = createRadixNode({ type, parent: node });\n      node.children.set(section, childNode);\n      if (type === NODE_TYPES.PLACEHOLDER) {\n        childNode.paramName = section === \"*\" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);\n        node.placeholderChildren.push(childNode);\n        isStaticRoute = false;\n      } else if (type === NODE_TYPES.WILDCARD) {\n        node.wildcardChildNode = childNode;\n        childNode.paramName = section.slice(\n          3\n          /* \"**:\" */\n        ) || \"_\";\n        isStaticRoute = false;\n      }\n      matchedNodes.push(childNode);\n      node = childNode;\n    }\n  }\n  for (const [depth, node2] of matchedNodes.entries()) {\n    node2.maxDepth = Math.max(matchedNodes.length - depth, node2.maxDepth || 0);\n  }\n  node.data = data;\n  if (isStaticRoute === true) {\n    ctx.staticRoutesMap[path] = node;\n  }\n  return node;\n}\nfunction remove(ctx, path) {\n  let success = false;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  for (const section of sections) {\n    node = node.children.get(section);\n    if (!node) {\n      return success;\n    }\n  }\n  if (node.data) {\n    const lastSection = sections.at(-1) || \"\";\n    node.data = null;\n    if (Object.keys(node.children).length === 0 && node.parent) {\n      node.parent.children.delete(lastSection);\n      node.parent.wildcardChildNode = null;\n      node.parent.placeholderChildren = [];\n    }\n    success = true;\n  }\n  return success;\n}\nfunction createRadixNode(options = {}) {\n  return {\n    type: options.type || NODE_TYPES.NORMAL,\n    maxDepth: 0,\n    parent: options.parent || null,\n    children: /* @__PURE__ */ new Map(),\n    data: options.data || null,\n    paramName: options.paramName || null,\n    wildcardChildNode: null,\n    placeholderChildren: []\n  };\n}\nfunction getNodeType(str) {\n  if (str.startsWith(\"**\")) {\n    return NODE_TYPES.WILDCARD;\n  }\n  if (str[0] === \":\" || str === \"*\") {\n    return NODE_TYPES.PLACEHOLDER;\n  }\n  return NODE_TYPES.NORMAL;\n}\n\nfunction toRouteMatcher(router) {\n  const table = _routerNodeToTable(\"\", router.ctx.rootNode);\n  return _createMatcher(table, router.ctx.options.strictTrailingSlash);\n}\nfunction _createMatcher(table, strictTrailingSlash) {\n  return {\n    ctx: { table },\n    matchAll: (path) => _matchRoutes(path, table, strictTrailingSlash)\n  };\n}\nfunction _createRouteTable() {\n  return {\n    static: /* @__PURE__ */ new Map(),\n    wildcard: /* @__PURE__ */ new Map(),\n    dynamic: /* @__PURE__ */ new Map()\n  };\n}\nfunction _exportMatcherFromTable(table) {\n  const obj = /* @__PURE__ */ Object.create(null);\n  for (const property in table) {\n    obj[property] = property === \"dynamic\" ? Object.fromEntries(\n      [...table[property].entries()].map(([key, value]) => [\n        key,\n        _exportMatcherFromTable(value)\n      ])\n    ) : Object.fromEntries(table[property].entries());\n  }\n  return obj;\n}\nfunction exportMatcher(matcher) {\n  return _exportMatcherFromTable(matcher.ctx.table);\n}\nfunction _createTableFromExport(matcherExport) {\n  const table = {};\n  for (const property in matcherExport) {\n    table[property] = property === \"dynamic\" ? new Map(\n      Object.entries(matcherExport[property]).map(([key, value]) => [\n        key,\n        _createTableFromExport(value)\n      ])\n    ) : new Map(\n      Object.entries(matcherExport[property])\n    );\n  }\n  return table;\n}\nfunction createMatcherFromExport(matcherExport) {\n  return _createMatcher(_createTableFromExport(matcherExport));\n}\nfunction _matchRoutes(path, table, strictTrailingSlash) {\n  if (strictTrailingSlash !== true && path.endsWith(\"/\")) {\n    path = path.slice(0, -1) || \"/\";\n  }\n  const matches = [];\n  for (const [key, value] of _sortRoutesMap(table.wildcard)) {\n    if (path === key || path.startsWith(key + \"/\")) {\n      matches.push(value);\n    }\n  }\n  for (const [key, value] of _sortRoutesMap(table.dynamic)) {\n    if (path.startsWith(key + \"/\")) {\n      const subPath = \"/\" + path.slice(key.length).split(\"/\").splice(2).join(\"/\");\n      matches.push(..._matchRoutes(subPath, value));\n    }\n  }\n  const staticMatch = table.static.get(path);\n  if (staticMatch) {\n    matches.push(staticMatch);\n  }\n  return matches.filter(Boolean);\n}\nfunction _sortRoutesMap(m) {\n  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);\n}\nfunction _routerNodeToTable(initialPath, initialNode) {\n  const table = _createRouteTable();\n  function _addNode(path, node) {\n    if (path) {\n      if (node.type === NODE_TYPES.NORMAL && !(path.includes(\"*\") || path.includes(\":\"))) {\n        if (node.data) {\n          table.static.set(path, node.data);\n        }\n      } else if (node.type === NODE_TYPES.WILDCARD) {\n        table.wildcard.set(path.replace(\"/**\", \"\"), node.data);\n      } else if (node.type === NODE_TYPES.PLACEHOLDER) {\n        const subTable = _routerNodeToTable(\"\", node);\n        if (node.data) {\n          subTable.static.set(\"/\", node.data);\n        }\n        table.dynamic.set(path.replace(/\\/\\*|\\/:\\w+/, \"\"), subTable);\n        return;\n      }\n    }\n    for (const [childPath, child] of node.children.entries()) {\n      _addNode(`${path}/${childPath}`.replace(\"//\", \"/\"), child);\n    }\n  }\n  _addNode(initialPath, initialNode);\n  return table;\n}\n\nexport { NODE_TYPES, createMatcherFromExport, createRouter, exportMatcher, toRouteMatcher };\n","function isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","export function rawHeaders(headers) {\n  const rawHeaders2 = [];\n  for (const key in headers) {\n    if (Array.isArray(headers[key])) {\n      for (const h of headers[key]) {\n        rawHeaders2.push(key, h);\n      }\n    } else {\n      rawHeaders2.push(key, headers[key]);\n    }\n  }\n  return rawHeaders2;\n}\nexport function mergeFns(...functions) {\n  return function(...args) {\n    for (const fn of functions) {\n      fn(...args);\n    }\n  };\n}\nexport function createNotImplementedError(name) {\n  throw new Error(`[unenv] ${name} is not implemented yet!`);\n}\nexport function notImplemented(name) {\n  const fn = () => {\n    throw createNotImplementedError(name);\n  };\n  return Object.assign(fn, { __unenv__: true });\n}\nexport function notImplementedClass(name) {\n  return class {\n    __unenv__ = true;\n    constructor() {\n      throw new Error(`[unenv] ${name} is not implemented yet!`);\n    }\n  };\n}\n","let defaultMaxListeners = 10;\nexport class EventEmitter {\n  __unenv__ = true;\n  _events = /* @__PURE__ */ Object.create(null);\n  _maxListeners;\n  static get defaultMaxListeners() {\n    return defaultMaxListeners;\n  }\n  static set defaultMaxListeners(arg) {\n    if (typeof arg !== \"number\" || arg < 0 || Number.isNaN(arg)) {\n      throw new RangeError(\n        'The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\"\n      );\n    }\n    defaultMaxListeners = arg;\n  }\n  setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || Number.isNaN(n)) {\n      throw new RangeError(\n        'The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\"\n      );\n    }\n    this._maxListeners = n;\n    return this;\n  }\n  getMaxListeners() {\n    return _getMaxListeners(this);\n  }\n  emit(type, ...args) {\n    if (!this._events[type] || this._events[type].length === 0) {\n      return false;\n    }\n    if (type === \"error\") {\n      let er;\n      if (args.length > 0) {\n        er = args[0];\n      }\n      if (er instanceof Error) {\n        throw er;\n      }\n      const err = new Error(\n        \"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\")\n      );\n      err.context = er;\n      throw err;\n    }\n    for (const _listener of this._events[type]) {\n      (_listener.listener || _listener).apply(this, args);\n    }\n    return true;\n  }\n  addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n  on(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n  prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  }\n  once(type, listener) {\n    return this.on(type, _wrapOnce(this, type, listener));\n  }\n  prependOnceListener(type, listener) {\n    return this.prependListener(type, _wrapOnce(this, type, listener));\n  }\n  removeListener(type, listener) {\n    return _removeListener(this, type, listener);\n  }\n  off(type, listener) {\n    return this.removeListener(type, listener);\n  }\n  removeAllListeners(type) {\n    return _removeAllListeners(this, type);\n  }\n  listeners(type) {\n    return _listeners(this, type, true);\n  }\n  rawListeners(type) {\n    return _listeners(this, type, false);\n  }\n  listenerCount(type) {\n    return this.rawListeners(type).length;\n  }\n  eventNames() {\n    return Object.keys(this._events);\n  }\n}\nexport function once(emitter, name) {\n  return new Promise(function(resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === \"function\") {\n        emitter.removeListener(\"error\", errorListener);\n      }\n      resolve(Array.prototype.slice.call(arguments));\n    }\n    _eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== \"error\") {\n      _addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\nfunction _addListener(target, type, listener, prepend) {\n  _checkListener(listener);\n  if (target._events.newListener !== void 0) {\n    target.emit(\"newListener\", type, listener.listener || listener);\n  }\n  if (!target._events[type]) {\n    target._events[type] = [];\n  }\n  if (prepend) {\n    target._events[type].unshift(listener);\n  } else {\n    target._events[type].push(listener);\n  }\n  const maxListeners = _getMaxListeners(target);\n  if (maxListeners > 0 && target._events[type].length > maxListeners && !target._events[type].warned) {\n    target._events[type].warned = true;\n    const warning = new Error(\n      `[unenv] Possible EventEmitter memory leak detected. ${target._events[type].length} ${type} listeners added. Use emitter.setMaxListeners() to increase limit`\n    );\n    warning.name = \"MaxListenersExceededWarning\";\n    warning.emitter = target;\n    warning.type = type;\n    warning.count = target._events[type]?.length;\n    console.warn(warning);\n  }\n  return target;\n}\nfunction _removeListener(target, type, listener) {\n  _checkListener(listener);\n  if (!target._events[type] || target._events[type].length === 0) {\n    return target;\n  }\n  const lenBeforeFilter = target._events[type].length;\n  target._events[type] = target._events[type].filter((fn) => fn !== listener);\n  if (lenBeforeFilter === target._events[type].length) {\n    return target;\n  }\n  if (target._events.removeListener) {\n    target.emit(\"removeListener\", type, listener.listener || listener);\n  }\n  if (target._events[type].length === 0) {\n    delete target._events[type];\n  }\n  return target;\n}\nfunction _removeAllListeners(target, type) {\n  if (!target._events[type] || target._events[type].length === 0) {\n    return target;\n  }\n  if (target._events.removeListener) {\n    for (const _listener of target._events[type]) {\n      target.emit(\"removeListener\", type, _listener.listener || _listener);\n    }\n  }\n  delete target._events[type];\n  return target;\n}\nfunction _wrapOnce(target, type, listener) {\n  let fired = false;\n  const wrapper = (...args) => {\n    if (fired) {\n      return;\n    }\n    target.removeListener(type, wrapper);\n    fired = true;\n    return args.length === 0 ? listener.call(target) : listener.apply(target, args);\n  };\n  wrapper.listener = listener;\n  return wrapper;\n}\nfunction _getMaxListeners(target) {\n  return target._maxListeners ?? EventEmitter.defaultMaxListeners;\n}\nfunction _listeners(target, type, unwrap) {\n  let listeners = target._events[type];\n  if (typeof listeners === \"function\") {\n    listeners = [listeners];\n  }\n  return unwrap ? listeners.map((l) => l.listener || l) : listeners;\n}\nfunction _checkListener(listener) {\n  if (typeof listener !== \"function\") {\n    throw new TypeError(\n      'The \"listener\" argument must be of type Function. Received type ' + typeof listener\n    );\n  }\n}\nfunction _addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === \"function\") {\n    _eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n  }\n}\nfunction _eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, listener);\n  } else {\n    throw new TypeError(\n      'The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter\n    );\n  }\n}\n","import { EventEmitter as _EventEmitter, once as _once } from \"./_events.mjs\";\nexport const EventEmitter = globalThis.EventEmitter || _EventEmitter;\nexport const once = _once;\nexport default {\n  EventEmitter,\n  once\n};\n","import { createNotImplementedError } from \"../../_internal/utils.mjs\";\nimport { EventEmitter } from \"../events/index.mjs\";\nexport class _Readable extends EventEmitter {\n  __unenv__ = true;\n  readableEncoding = null;\n  readableEnded = true;\n  readableFlowing = false;\n  readableHighWaterMark = 0;\n  readableLength = 0;\n  readableObjectMode = false;\n  readableAborted = false;\n  readableDidRead = false;\n  closed = false;\n  errored = null;\n  readable = false;\n  destroyed = false;\n  static from(_iterable, options) {\n    return new _Readable(options);\n  }\n  constructor(_opts) {\n    super();\n  }\n  _read(_size) {\n  }\n  read(_size) {\n  }\n  setEncoding(_encoding) {\n    return this;\n  }\n  pause() {\n    return this;\n  }\n  resume() {\n    return this;\n  }\n  isPaused() {\n    return true;\n  }\n  unpipe(_destination) {\n    return this;\n  }\n  unshift(_chunk, _encoding) {\n  }\n  wrap(_oldStream) {\n    return this;\n  }\n  push(_chunk, _encoding) {\n    return false;\n  }\n  _destroy(_error, _callback) {\n    this.removeAllListeners();\n  }\n  destroy(error) {\n    this.destroyed = true;\n    this._destroy(error);\n    return this;\n  }\n  pipe(_destenition, _options) {\n    return {};\n  }\n  compose(stream, options) {\n    throw new Error(\"[unenv] Method not implemented.\");\n  }\n  [Symbol.asyncDispose]() {\n    this.destroy();\n    return Promise.resolve();\n  }\n  // eslint-disable-next-line require-yield\n  async *[Symbol.asyncIterator]() {\n    throw createNotImplementedError(\"Readable.asyncIterator\");\n  }\n  iterator(options) {\n    throw createNotImplementedError(\"Readable.iterator\");\n  }\n  map(fn, options) {\n    throw createNotImplementedError(\"Readable.map\");\n  }\n  filter(fn, options) {\n    throw createNotImplementedError(\"Readable.filter\");\n  }\n  forEach(fn, options) {\n    throw createNotImplementedError(\"Readable.forEach\");\n  }\n  reduce(fn, initialValue, options) {\n    throw createNotImplementedError(\"Readable.reduce\");\n  }\n  find(fn, options) {\n    throw createNotImplementedError(\"Readable.find\");\n  }\n  findIndex(fn, options) {\n    throw createNotImplementedError(\"Readable.findIndex\");\n  }\n  some(fn, options) {\n    throw createNotImplementedError(\"Readable.some\");\n  }\n  toArray(options) {\n    throw createNotImplementedError(\"Readable.toArray\");\n  }\n  every(fn, options) {\n    throw createNotImplementedError(\"Readable.every\");\n  }\n  flatMap(fn, options) {\n    throw createNotImplementedError(\"Readable.flatMap\");\n  }\n  drop(limit, options) {\n    throw createNotImplementedError(\"Readable.drop\");\n  }\n  take(limit, options) {\n    throw createNotImplementedError(\"Readable.take\");\n  }\n  asIndexedPairs(options) {\n    throw createNotImplementedError(\"Readable.asIndexedPairs\");\n  }\n}\nexport const Readable = globalThis.Readable || _Readable;\n","import { EventEmitter } from \"../events/index.mjs\";\nclass _Writable extends EventEmitter {\n  __unenv__ = true;\n  writable = true;\n  writableEnded = false;\n  writableFinished = false;\n  writableHighWaterMark = 0;\n  writableLength = 0;\n  writableObjectMode = false;\n  writableCorked = 0;\n  closed = false;\n  errored = null;\n  writableNeedDrain = false;\n  destroyed = false;\n  _data;\n  _encoding = \"utf-8\";\n  constructor(_opts) {\n    super();\n  }\n  pipe(_destenition, _options) {\n    return {};\n  }\n  _write(chunk, encoding, callback) {\n    if (this.writableEnded) {\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    if (this._data === void 0) {\n      this._data = chunk;\n    } else {\n      const a = typeof this._data === \"string\" ? Buffer.from(this._data, this._encoding || encoding || \"utf8\") : this._data;\n      const b = typeof chunk === \"string\" ? Buffer.from(chunk, encoding || this._encoding || \"utf8\") : chunk;\n      this._data = Buffer.concat([a, b]);\n    }\n    this._encoding = encoding;\n    if (callback) {\n      callback();\n    }\n  }\n  _writev(_chunks, _callback) {\n  }\n  _destroy(_error, _callback) {\n  }\n  _final(_callback) {\n  }\n  write(chunk, arg2, arg3) {\n    const encoding = typeof arg2 === \"string\" ? this._encoding : \"utf-8\";\n    const cb = typeof arg2 === \"function\" ? arg2 : typeof arg3 === \"function\" ? arg3 : void 0;\n    this._write(chunk, encoding, cb);\n    return true;\n  }\n  setDefaultEncoding(_encoding) {\n    return this;\n  }\n  end(arg1, arg2, arg3) {\n    const callback = typeof arg1 === \"function\" ? arg1 : typeof arg2 === \"function\" ? arg2 : typeof arg3 === \"function\" ? arg3 : void 0;\n    if (this.writableEnded) {\n      if (callback) {\n        callback();\n      }\n      return this;\n    }\n    const data = arg1 === callback ? void 0 : arg1;\n    if (data) {\n      const encoding = arg2 === callback ? void 0 : arg2;\n      this.write(data, encoding, callback);\n    }\n    this.writableEnded = true;\n    this.writableFinished = true;\n    this.emit(\"close\");\n    this.emit(\"finish\");\n    return this;\n  }\n  cork() {\n  }\n  uncork() {\n  }\n  destroy(_error) {\n    this.destroyed = true;\n    delete this._data;\n    this.removeAllListeners();\n    return this;\n  }\n  compose(stream, options) {\n    throw new Error(\"[h3] Method not implemented.\");\n  }\n}\nexport const Writable = globalThis.Writable || _Writable;\n","import { mergeFns } from \"../../_internal/utils.mjs\";\nimport { Readable } from \"./readable.mjs\";\nimport { Writable } from \"./writable.mjs\";\nconst __Duplex = class {\n  allowHalfOpen = true;\n  _destroy;\n  constructor(readable = new Readable(), writable = new Writable()) {\n    Object.assign(this, readable);\n    Object.assign(this, writable);\n    this._destroy = mergeFns(readable._destroy, writable._destroy);\n  }\n};\nfunction getDuplex() {\n  Object.assign(__Duplex.prototype, Readable.prototype);\n  Object.assign(__Duplex.prototype, Writable.prototype);\n  return __Duplex;\n}\nexport const _Duplex = /* @__PURE__ */ getDuplex();\nexport const Duplex = globalThis.Duplex || _Duplex;\n","import { Duplex } from \"../stream/duplex.mjs\";\nexport class Socket extends Duplex {\n  __unenv__ = true;\n  bufferSize = 0;\n  bytesRead = 0;\n  bytesWritten = 0;\n  connecting = false;\n  destroyed = false;\n  pending = false;\n  localAddress = \"\";\n  localPort = 0;\n  remoteAddress = \"\";\n  remoteFamily = \"\";\n  remotePort = 0;\n  autoSelectFamilyAttemptedAddresses = [];\n  readyState = \"readOnly\";\n  constructor(_options) {\n    super();\n  }\n  write(_buffer, _arg1, _arg2) {\n    return false;\n  }\n  connect(_arg1, _arg2, _arg3) {\n    return this;\n  }\n  end(_arg1, _arg2, _arg3) {\n    return this;\n  }\n  setEncoding(_encoding) {\n    return this;\n  }\n  pause() {\n    return this;\n  }\n  resume() {\n    return this;\n  }\n  setTimeout(_timeout, _callback) {\n    return this;\n  }\n  setNoDelay(_noDelay) {\n    return this;\n  }\n  setKeepAlive(_enable, _initialDelay) {\n    return this;\n  }\n  address() {\n    return {};\n  }\n  unref() {\n    return this;\n  }\n  ref() {\n    return this;\n  }\n  destroySoon() {\n    this.destroy();\n  }\n  resetAndDestroy() {\n    const err = new Error(\"ERR_SOCKET_CLOSED\");\n    err.code = \"ERR_SOCKET_CLOSED\";\n    this.destroy(err);\n    return this;\n  }\n}\nexport class SocketAddress {\n  __unenv__ = true;\n  address;\n  family;\n  port;\n  flowlabel;\n  constructor(options) {\n    this.address = options.address;\n    this.family = options.family;\n    this.port = options.port;\n    this.flowlabel = options.flowlabel;\n  }\n}\n","import { Socket } from \"../net/socket.mjs\";\nimport { Readable } from \"../stream/readable.mjs\";\nimport { rawHeaders } from \"../../_internal/utils.mjs\";\nexport class IncomingMessage extends Readable {\n  __unenv__ = {};\n  aborted = false;\n  httpVersion = \"1.1\";\n  httpVersionMajor = 1;\n  httpVersionMinor = 1;\n  complete = true;\n  connection;\n  socket;\n  headers = {};\n  trailers = {};\n  method = \"GET\";\n  url = \"/\";\n  statusCode = 200;\n  statusMessage = \"\";\n  closed = false;\n  errored = null;\n  readable = false;\n  constructor(socket) {\n    super();\n    this.socket = this.connection = socket || new Socket();\n  }\n  get rawHeaders() {\n    return rawHeaders(this.headers);\n  }\n  get rawTrailers() {\n    return [];\n  }\n  setTimeout(_msecs, _callback) {\n    return this;\n  }\n  get headersDistinct() {\n    return _distinct(this.headers);\n  }\n  get trailersDistinct() {\n    return _distinct(this.trailers);\n  }\n}\nfunction _distinct(obj) {\n  const d = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key) {\n      d[key] = (Array.isArray(value) ? value : [value]).filter(\n        Boolean\n      );\n    }\n  }\n  return d;\n}\n","import { Writable } from \"../stream/writable.mjs\";\nexport class ServerResponse extends Writable {\n  __unenv__ = true;\n  statusCode = 200;\n  statusMessage = \"\";\n  upgrading = false;\n  chunkedEncoding = false;\n  shouldKeepAlive = false;\n  useChunkedEncodingByDefault = false;\n  sendDate = false;\n  finished = false;\n  headersSent = false;\n  strictContentLength = false;\n  connection = null;\n  socket = null;\n  req;\n  _headers = {};\n  constructor(req) {\n    super();\n    this.req = req;\n  }\n  assignSocket(socket) {\n    socket._httpMessage = this;\n    this.socket = socket;\n    this.connection = socket;\n    this.emit(\"socket\", socket);\n    this._flush();\n  }\n  _flush() {\n    this.flushHeaders();\n  }\n  detachSocket(_socket) {\n  }\n  writeContinue(_callback) {\n  }\n  writeHead(statusCode, arg1, arg2) {\n    if (statusCode) {\n      this.statusCode = statusCode;\n    }\n    if (typeof arg1 === \"string\") {\n      this.statusMessage = arg1;\n      arg1 = void 0;\n    }\n    const headers = arg2 || arg1;\n    if (headers) {\n      if (Array.isArray(headers)) {\n      } else {\n        for (const key in headers) {\n          this.setHeader(key, headers[key]);\n        }\n      }\n    }\n    this.headersSent = true;\n    return this;\n  }\n  writeProcessing() {\n  }\n  setTimeout(_msecs, _callback) {\n    return this;\n  }\n  appendHeader(name, value) {\n    name = name.toLowerCase();\n    const current = this._headers[name];\n    const all = [\n      ...Array.isArray(current) ? current : [current],\n      ...Array.isArray(value) ? value : [value]\n    ].filter(Boolean);\n    this._headers[name] = all.length > 1 ? all : all[0];\n    return this;\n  }\n  setHeader(name, value) {\n    this._headers[name.toLowerCase()] = value;\n    return this;\n  }\n  getHeader(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  getHeaders() {\n    return this._headers;\n  }\n  getHeaderNames() {\n    return Object.keys(this._headers);\n  }\n  hasHeader(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  removeHeader(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  addTrailers(_headers) {\n  }\n  flushHeaders() {\n  }\n  writeEarlyHints(_headers, cb) {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n  }\n}\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1, decode, decodePath, withLeadingSlash, parseURL, joinURL } from 'ufo';\nimport { parse as parse$1, serialize } from 'cookie-es';\nimport { objectHash } from 'ohash';\nimport { createRouter as createRouter$1, toRouteMatcher } from 'radix3';\nimport destr from 'destr';\nimport { defu } from 'defu';\nimport crypto from 'uncrypto';\nimport { seal, defaults, unseal } from 'iron-webcrypto';\nimport { IncomingMessage, ServerResponse } from 'unenv/runtime/node/http/index';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base || base === \"/\") {\n    return handler;\n  }\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _path = event._path || event.node.req.url || \"/\";\n    event._path = withoutBase(event.path || \"/\", base);\n    event.node.req.url = event._path;\n    try {\n      return await handler(event);\n    } finally {\n      event._path = event.node.req.url = _path;\n    }\n  });\n}\n\nfunction hasProp(obj, prop) {\n  try {\n    return prop in obj;\n  } catch {\n    return false;\n  }\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Error extends Error {\n  constructor(message, opts = {}) {\n    super(message, opts);\n    __publicField$2(this, \"statusCode\", 500);\n    __publicField$2(this, \"fatal\", false);\n    __publicField$2(this, \"unhandled\", false);\n    __publicField$2(this, \"statusMessage\");\n    __publicField$2(this, \"data\");\n    __publicField$2(this, \"cause\");\n    if (opts.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\n__publicField$2(H3Error, \"__h3_error__\", true);\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage ?? \"\", {\n    cause: input.cause || input\n  });\n  if (hasProp(input, \"stack\")) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\n  } else if (input.status) {\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (err.statusMessage) {\n    const originalMessage = err.statusMessage;\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\n    if (sanitizedMessage !== originalMessage) {\n      console.warn(\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.\"\n      );\n    }\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.handled) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.handled) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  setResponseStatus(event, _code, h3Error.statusMessage);\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      const _value = (s[1] || \"\").trim().replace(/\"/g, \"\");\n      dataObj[key] = Buffer.from(_value, \"latin1\").toString(\"utf8\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nasync function validateData(data, fn) {\n  try {\n    const res = await fn(data);\n    if (res === false) {\n      throw createValidationError();\n    }\n    if (res === true) {\n      return data;\n    }\n    return res ?? data;\n  } catch (error) {\n    throw createValidationError(error);\n  }\n}\nfunction createValidationError(validateError) {\n  throw createError({\n    status: 400,\n    statusMessage: \"Validation Error\",\n    message: validateError?.message || \"Validation Error\",\n    data: validateError\n  });\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.path || \"\");\n}\nfunction getValidatedQuery(event, validate) {\n  const query = getQuery(event);\n  return validateData(query, validate);\n}\nfunction getRouterParams(event, opts = {}) {\n  let params = event.context.params || {};\n  if (opts.decode) {\n    params = { ...params };\n    for (const key in params) {\n      params[key] = decode(params[key]);\n    }\n  }\n  return params;\n}\nfunction getValidatedRouterParams(event, validate, opts = {}) {\n  const routerParams = getRouterParams(event, opts);\n  return validateData(routerParams, validate);\n}\nfunction getRouterParam(event, name, opts = {}) {\n  const params = getRouterParams(event, opts);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  if (allowHead && event.method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (event.method === expected) {\n      return true;\n    }\n  } else if (expected.includes(event.method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\nfunction getRequestHost(event, opts = {}) {\n  if (opts.xForwardedHost) {\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\n    if (xForwardedHost) {\n      return xForwardedHost;\n    }\n  }\n  return event.node.req.headers.host || \"localhost\";\n}\nfunction getRequestProtocol(event, opts = {}) {\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\n    return \"https\";\n  }\n  return event.node.req.connection?.encrypted ? \"https\" : \"http\";\n}\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\nfunction getRequestPath(event) {\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\n  return path;\n}\nfunction getRequestURL(event, opts = {}) {\n  const host = getRequestHost(event, opts);\n  const protocol = getRequestProtocol(event, opts);\n  const path = (event.node.req.originalUrl || event.path).replace(\n    /^[/\\\\]+/g,\n    \"/\"\n  );\n  return new URL(path, `${protocol}://${host}`);\n}\nfunction toWebRequest(event) {\n  return event.web?.request || new Request(getRequestURL(event), {\n    // @ts-ignore Undici option\n    duplex: \"half\",\n    method: event.method,\n    headers: event.headers,\n    body: getRequestWebStream(event)\n  });\n}\nfunction getRequestIP(event, opts = {}) {\n  if (event.context.clientAddress) {\n    return event.context.clientAddress;\n  }\n  if (opts.xForwardedFor) {\n    const xForwardedFor = getRequestHeader(event, \"x-forwarded-for\")?.split(\",\").shift()?.trim();\n    if (xForwardedFor) {\n      return xForwardedFor;\n    }\n  }\n  if (event.node.req.socket.remoteAddress) {\n    return event.node.req.socket.remoteAddress;\n  }\n}\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;\n  if (_rawBody) {\n    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {\n      if (Buffer.isBuffer(_resolved)) {\n        return _resolved;\n      }\n      if (typeof _resolved.pipeTo === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                chunks.push(chunk);\n              },\n              close() {\n                resolve(Buffer.concat(chunks));\n              },\n              abort(reason) {\n                reject(reason);\n              }\n            })\n          ).catch(reject);\n        });\n      } else if (typeof _resolved.pipe === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.on(\"data\", (chunk) => {\n            chunks.push(chunk);\n          }).on(\"end\", () => {\n            resolve(Buffer.concat(chunks));\n          }).on(\"error\", reject);\n        });\n      }\n      if (_resolved.constructor === Object) {\n        return Buffer.from(JSON.stringify(_resolved));\n      }\n      if (_resolved instanceof URLSearchParams) {\n        return Buffer.from(_resolved.toString());\n      }\n      return Buffer.from(_resolved);\n    });\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\") && !String(event.node.req.headers[\"transfer-encoding\"] ?? \"\").split(\",\").map((e) => e.trim()).filter(Boolean).includes(\"chunked\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event, options = {}) {\n  const request = event.node.req;\n  if (hasProp(request, ParsedBodySymbol)) {\n    return request[ParsedBodySymbol];\n  }\n  const contentType = request.headers[\"content-type\"] || \"\";\n  const body = await readRawBody(event);\n  let parsed;\n  if (contentType === \"application/json\") {\n    parsed = _parseJSON(body, options.strict ?? true);\n  } else if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n    parsed = _parseURLEncodedBody(body);\n  } else if (contentType.startsWith(\"text/\")) {\n    parsed = body;\n  } else {\n    parsed = _parseJSON(body, options.strict ?? false);\n  }\n  request[ParsedBodySymbol] = parsed;\n  return parsed;\n}\nasync function readValidatedBody(event, validate) {\n  const _body = await readBody(event, { strict: true });\n  return validateData(_body, validate);\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\nasync function readFormData(event) {\n  return await toWebRequest(event).formData();\n}\nfunction getRequestWebStream(event) {\n  if (!PayloadMethods$1.includes(event.method)) {\n    return;\n  }\n  const bodyStream = event.web?.request?.body || event._requestBody;\n  if (bodyStream) {\n    return bodyStream;\n  }\n  const _hasRawBody = RawBodySymbol in event.node.req || \"rawBody\" in event.node.req || \"body\" in event.node.req || \"__unenv__\" in event.node.req;\n  if (_hasRawBody) {\n    return new ReadableStream({\n      async start(controller) {\n        const _rawBody = await readRawBody(event, false);\n        if (_rawBody) {\n          controller.enqueue(_rawBody);\n        }\n        controller.close();\n      }\n    });\n  }\n  return new ReadableStream({\n    start: (controller) => {\n      event.node.req.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      event.node.req.on(\"end\", () => {\n        controller.close();\n      });\n      event.node.req.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    }\n  });\n}\nfunction _parseJSON(body = \"\", strict) {\n  if (!body) {\n    return void 0;\n  }\n  try {\n    return destr(body, { strict });\n  } catch {\n    throw createError({\n      statusCode: 400,\n      statusMessage: \"Bad Request\",\n      message: \"Invalid JSON body\"\n    });\n  }\n}\nfunction _parseURLEncodedBody(body) {\n  const form = new URLSearchParams(body);\n  const parsedForm = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of form.entries()) {\n    if (hasProp(parsedForm, key)) {\n      if (!Array.isArray(parsedForm[key])) {\n        parsedForm[key] = [parsedForm[key]];\n      }\n      parsedForm[key].push(value);\n    } else {\n      parsedForm[key] = value;\n    }\n  }\n  return parsedForm;\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    if (!event.handled) {\n      event.node.res.end();\n    }\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\nfunction sanitizeStatusMessage(statusMessage = \"\") {\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\n}\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\n  if (!statusCode) {\n    return defaultStatusCode;\n  }\n  if (typeof statusCode === \"string\") {\n    statusCode = Number.parseInt(statusCode, 10);\n  }\n  if (statusCode < 100 || statusCode > 999) {\n    return defaultStatusCode;\n  }\n  return statusCode;\n}\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  serializeOptions = { path: \"/\", ...serializeOptions };\n  const cookieStr = serialize(name, value, serializeOptions);\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\n  if (!Array.isArray(setCookies)) {\n    setCookies = [setCookies];\n  }\n  const _optionsHash = objectHash(serializeOptions);\n  setCookies = setCookies.filter((cookieValue) => {\n    return cookieValue && _optionsHash !== objectHash(parse$1(cookieValue));\n  });\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitCookiesString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start));\n    }\n  }\n  return cookiesStrings;\n}\n\nfunction serializeIterableValue(value) {\n  switch (typeof value) {\n    case \"string\": {\n      return value;\n    }\n    case \"boolean\":\n    case \"number\":\n    case \"bigint\":\n    case \"symbol\": {\n      return value.toString();\n    }\n    case \"function\":\n    case \"undefined\": {\n      return void 0;\n    }\n    case \"object\": {\n      if (value instanceof Uint8Array) {\n        return value;\n      }\n      return JSON.stringify(value);\n    }\n  }\n}\nfunction coerceIterable(iterable) {\n  if (typeof iterable === \"function\") {\n    iterable = iterable();\n  }\n  if (Symbol.iterator in iterable) {\n    return iterable[Symbol.iterator]();\n  }\n  if (Symbol.asyncIterator in iterable) {\n    return iterable[Symbol.asyncIterator]();\n  }\n  return iterable;\n}\n\nconst defer = typeof setImmediate === \"undefined\" ? (fn) => fn() : setImmediate;\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      if (!event.handled) {\n        event.node.res.end(data);\n      }\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code) {\n  if (event.handled) {\n    return;\n  }\n  if (!code && event.node.res.statusCode !== 200) {\n    code = event.node.res.statusCode;\n  }\n  const _code = sanitizeStatusCode(code, 204);\n  if (_code === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.writeHead(_code);\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  if (code) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      code,\n      event.node.res.statusCode\n    );\n  }\n  if (text) {\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = sanitizeStatusCode(\n    code,\n    event.node.res.statusCode\n  );\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(\n      name,\n      value\n    );\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction clearResponseHeaders(event, headerNames) {\n  if (headerNames && headerNames.length > 0) {\n    for (const name of headerNames) {\n      removeResponseHeader(event, name);\n    }\n  } else {\n    for (const [name] of Object.entries(getResponseHeaders(event))) {\n      removeResponseHeader(event, name);\n    }\n  }\n}\nfunction removeResponseHeader(event, name) {\n  return event.node.res.removeHeader(name);\n}\nfunction isStream(data) {\n  if (!data || typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof data.pipe === \"function\") {\n    if (typeof data._read === \"function\") {\n      return true;\n    }\n    if (typeof data.abort === \"function\") {\n      return true;\n    }\n  }\n  if (typeof data.pipeTo === \"function\") {\n    return true;\n  }\n  return false;\n}\nfunction isWebResponse(data) {\n  return typeof Response !== \"undefined\" && data instanceof Response;\n}\nfunction sendStream(event, stream) {\n  if (!stream || typeof stream !== \"object\") {\n    throw new Error(\"[h3] Invalid stream provided.\");\n  }\n  event.node.res._data = stream;\n  if (!event.node.res.socket) {\n    event._handled = true;\n    return Promise.resolve();\n  }\n  if (hasProp(stream, \"pipeTo\") && typeof stream.pipeTo === \"function\") {\n    return stream.pipeTo(\n      new WritableStream({\n        write(chunk) {\n          event.node.res.write(chunk);\n        }\n      })\n    ).then(() => {\n      event.node.res.end();\n    });\n  }\n  if (hasProp(stream, \"pipe\") && typeof stream.pipe === \"function\") {\n    return new Promise((resolve, reject) => {\n      stream.pipe(event.node.res);\n      if (stream.on) {\n        stream.on(\"end\", () => {\n          event.node.res.end();\n          resolve();\n        });\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      }\n      event.node.res.on(\"close\", () => {\n        if (stream.abort) {\n          stream.abort();\n        }\n      });\n    });\n  }\n  throw new Error(\"[h3] Invalid or incompatible stream provided.\");\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\nfunction sendWebResponse(event, response) {\n  for (const [key, value] of response.headers) {\n    if (key === \"set-cookie\") {\n      event.node.res.appendHeader(key, splitCookiesString(value));\n    } else {\n      event.node.res.setHeader(key, value);\n    }\n  }\n  if (response.status) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      response.status,\n      event.node.res.statusCode\n    );\n  }\n  if (response.statusText) {\n    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  }\n  if (response.redirected) {\n    event.node.res.setHeader(\"location\", response.url);\n  }\n  if (!response.body) {\n    event.node.res.end();\n    return;\n  }\n  return sendStream(event, response.body);\n}\nfunction sendIterable(event, iterable, options) {\n  const serializer = options?.serializer ?? serializeIterableValue;\n  const iterator = coerceIterable(iterable);\n  return sendStream(\n    event,\n    new ReadableStream({\n      async pull(controller) {\n        const { value, done } = await iterator.next();\n        if (value !== void 0) {\n          const chunk = serializer(value);\n          if (chunk !== void 0) {\n            controller.enqueue(chunk);\n          }\n        }\n        if (done) {\n          controller.close();\n        }\n      },\n      cancel() {\n        iterator.return?.();\n      }\n    })\n  );\n}\n\nfunction resolveCorsOptions(options = {}) {\n  const defaultOptions = {\n    origin: \"*\",\n    methods: \"*\",\n    allowHeaders: \"*\",\n    exposeHeaders: \"*\",\n    credentials: false,\n    maxAge: false,\n    preflight: {\n      statusCode: 204\n    }\n  };\n  return defu(options, defaultOptions);\n}\nfunction isPreflightRequest(event) {\n  const origin = getRequestHeader(event, \"origin\");\n  const accessControlRequestMethod = getRequestHeader(\n    event,\n    \"access-control-request-method\"\n  );\n  return event.method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\n}\nfunction isCorsOriginAllowed(origin, options) {\n  const { origin: originOption } = options;\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\n    return true;\n  }\n  if (Array.isArray(originOption)) {\n    return originOption.some((_origin) => {\n      if (_origin instanceof RegExp) {\n        return _origin.test(origin);\n      }\n      return origin === _origin;\n    });\n  }\n  return originOption(origin);\n}\nfunction createOriginHeaders(event, options) {\n  const { origin: originOption } = options;\n  const origin = getRequestHeader(event, \"origin\");\n  if (!origin || !originOption || originOption === \"*\") {\n    return { \"access-control-allow-origin\": \"*\" };\n  }\n  if (typeof originOption === \"string\") {\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\n  }\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\n}\nfunction createMethodsHeaders(options) {\n  const { methods } = options;\n  if (!methods) {\n    return {};\n  }\n  if (methods === \"*\") {\n    return { \"access-control-allow-methods\": \"*\" };\n  }\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\n}\nfunction createCredentialsHeaders(options) {\n  const { credentials } = options;\n  if (credentials) {\n    return { \"access-control-allow-credentials\": \"true\" };\n  }\n  return {};\n}\nfunction createAllowHeaderHeaders(event, options) {\n  const { allowHeaders } = options;\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\n    const header = getRequestHeader(event, \"access-control-request-headers\");\n    return header ? {\n      \"access-control-allow-headers\": header,\n      vary: \"access-control-request-headers\"\n    } : {};\n  }\n  return {\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\n    vary: \"access-control-request-headers\"\n  };\n}\nfunction createExposeHeaders(options) {\n  const { exposeHeaders } = options;\n  if (!exposeHeaders) {\n    return {};\n  }\n  if (exposeHeaders === \"*\") {\n    return { \"access-control-expose-headers\": exposeHeaders };\n  }\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\n}\nfunction appendCorsPreflightHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n  appendHeaders(event, createMethodsHeaders(options));\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\n}\nfunction appendCorsHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n}\n\nfunction handleCors(event, options) {\n  const _options = resolveCorsOptions(options);\n  if (isPreflightRequest(event)) {\n    appendCorsPreflightHeaders(event, options);\n    sendNoContent(event, _options.preflight.statusCode);\n    return true;\n  }\n  appendCorsHeaders(event, options);\n  return false;\n}\n\nasync function getRequestFingerprint(event, opts = {}) {\n  const fingerprint = [];\n  if (opts.ip !== false) {\n    fingerprint.push(\n      getRequestIP(event, { xForwardedFor: opts.xForwardedFor })\n    );\n  }\n  if (opts.method === true) {\n    fingerprint.push(event.method);\n  }\n  if (opts.path === true) {\n    fingerprint.push(event.path);\n  }\n  if (opts.userAgent === true) {\n    fingerprint.push(getRequestHeader(event, \"user-agent\"));\n  }\n  const fingerprintString = fingerprint.filter(Boolean).join(\"|\");\n  if (!fingerprintString) {\n    return null;\n  }\n  if (opts.hash === false) {\n    return fingerprintString;\n  }\n  const buffer = await crypto.subtle.digest(\n    opts.hash || \"SHA-1\",\n    new TextEncoder().encode(fingerprintString)\n  );\n  const hash = [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hash;\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\",\n  \"host\",\n  \"accept\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  let body;\n  let duplex;\n  if (PayloadMethods.has(event.method)) {\n    if (opts.streamRequest) {\n      body = getRequestWebStream(event);\n      duplex = \"half\";\n    } else {\n      body = await readRawBody(event, false).catch(() => void 0);\n    }\n  }\n  const method = opts.fetchOptions?.method || event.method;\n  const fetchHeaders = mergeHeaders(\n    getProxyRequestHeaders(event),\n    opts.fetchOptions?.headers,\n    opts.headers\n  );\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      method,\n      body,\n      duplex,\n      ...opts.fetchOptions,\n      headers: fetchHeaders\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  let response;\n  try {\n    response = await _getFetch(opts.fetch)(target, {\n      headers: opts.headers,\n      ignoreResponseError: true,\n      // make $ofetch.raw transparent\n      ...opts.fetchOptions\n    });\n  } catch (error) {\n    throw createError({\n      status: 502,\n      statusMessage: \"Bad Gateway\",\n      cause: error\n    });\n  }\n  event.node.res.statusCode = sanitizeStatusCode(\n    response.status,\n    event.node.res.statusCode\n  );\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  const cookies = [];\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    if (key === \"set-cookie\") {\n      cookies.push(...splitCookiesString(value));\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  if (cookies.length > 0) {\n    event.node.res.setHeader(\n      \"set-cookie\",\n      cookies.map((cookie) => {\n        if (opts.cookieDomainRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookieDomainRewrite,\n            \"domain\"\n          );\n        }\n        if (opts.cookiePathRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookiePathRewrite,\n            \"path\"\n          );\n        }\n        return cookie;\n      })\n    );\n  }\n  if (opts.onResponse) {\n    await opts.onResponse(event, response);\n  }\n  if (response._data !== void 0) {\n    return response._data;\n  }\n  if (event.handled) {\n    return;\n  }\n  if (opts.sendStream === false) {\n    const data = new Uint8Array(await response.arrayBuffer());\n    return event.node.res.end(data);\n  }\n  if (response.body) {\n    for await (const chunk of response.body) {\n      event.node.res.write(chunk);\n    }\n  }\n  return event.node.res.end();\n}\nfunction getProxyRequestHeaders(event) {\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  return headers;\n}\nfunction fetchWithEvent(event, req, init, options) {\n  return _getFetch(options?.fetch)(req, {\n    ...init,\n    context: init?.context || event.context,\n    headers: {\n      ...getProxyRequestHeaders(event),\n      ...init?.headers\n    }\n  });\n}\nfunction _getFetch(_fetch) {\n  if (_fetch) {\n    return _fetch;\n  }\n  if (globalThis.fetch) {\n    return globalThis.fetch;\n  }\n  throw new Error(\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n  );\n}\nfunction rewriteCookieProperty(header, map, property) {\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\n  return header.replace(\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\n    (match, prefix, previousValue) => {\n      let newValue;\n      if (previousValue in _map) {\n        newValue = _map[previousValue];\n      } else if (\"*\" in _map) {\n        newValue = _map[\"*\"];\n      } else {\n        return match;\n      }\n      return newValue ? prefix + newValue : \"\";\n    }\n  );\n}\nfunction mergeHeaders(defaults, ...inputs) {\n  const _inputs = inputs.filter(Boolean);\n  if (_inputs.length === 0) {\n    return defaults;\n  }\n  const merged = new Headers(defaults);\n  for (const input of _inputs) {\n    for (const [key, value] of Object.entries(input)) {\n      if (value !== void 0) {\n        merged.set(key, value);\n      }\n    }\n  }\n  return merged;\n}\n\nconst getSessionPromise = Symbol(\"getSession\");\nconst DEFAULT_NAME = \"h3\";\nconst DEFAULT_COOKIE = {\n  path: \"/\",\n  secure: true,\n  httpOnly: true\n};\nasync function useSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  await getSession(event, config);\n  const sessionManager = {\n    get id() {\n      return event.context.sessions?.[sessionName]?.id;\n    },\n    get data() {\n      return event.context.sessions?.[sessionName]?.data || {};\n    },\n    update: async (update) => {\n      await updateSession(event, config, update);\n      return sessionManager;\n    },\n    clear: () => {\n      clearSession(event, config);\n      return Promise.resolve(sessionManager);\n    }\n  };\n  return sessionManager;\n}\nasync function getSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (!event.context.sessions) {\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\n  }\n  const existingSession = event.context.sessions[sessionName];\n  if (existingSession) {\n    return existingSession[getSessionPromise] || existingSession;\n  }\n  const session = {\n    id: \"\",\n    createdAt: 0,\n    data: /* @__PURE__ */ Object.create(null)\n  };\n  event.context.sessions[sessionName] = session;\n  let sealedSession;\n  if (config.sessionHeader !== false) {\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\n    const headerValue = event.node.req.headers[headerName];\n    if (typeof headerValue === \"string\") {\n      sealedSession = headerValue;\n    }\n  }\n  if (!sealedSession) {\n    sealedSession = getCookie(event, sessionName);\n  }\n  if (sealedSession) {\n    const promise = unsealSession(event, config, sealedSession).catch(() => {\n    }).then((unsealed) => {\n      Object.assign(session, unsealed);\n      delete event.context.sessions[sessionName][getSessionPromise];\n      return session;\n    });\n    event.context.sessions[sessionName][getSessionPromise] = promise;\n    await promise;\n  }\n  if (!session.id) {\n    session.id = config.generateId?.() ?? (config.crypto || crypto).randomUUID();\n    session.createdAt = Date.now();\n    await updateSession(event, config);\n  }\n  return session;\n}\nasync function updateSession(event, config, update) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  if (typeof update === \"function\") {\n    update = update(session.data);\n  }\n  if (update) {\n    Object.assign(session.data, update);\n  }\n  if (config.cookie !== false) {\n    const sealed = await sealSession(event, config);\n    setCookie(event, sessionName, sealed, {\n      ...DEFAULT_COOKIE,\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\n      ...config.cookie\n    });\n  }\n  return session;\n}\nasync function sealSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\n    ...defaults,\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n    ...config.seal\n  });\n  return sealed;\n}\nasync function unsealSession(_event, config, sealed) {\n  const unsealed = await unseal(\n    config.crypto || crypto,\n    sealed,\n    config.password,\n    {\n      ...defaults,\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n      ...config.seal\n    }\n  );\n  if (config.maxAge) {\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\n    if (age > config.maxAge * 1e3) {\n      throw new Error(\"Session expired!\");\n    }\n  }\n  return unsealed;\n}\nfunction clearSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (event.context.sessions?.[sessionName]) {\n    delete event.context.sessions[sessionName];\n  }\n  setCookie(event, sessionName, \"\", {\n    ...DEFAULT_COOKIE,\n    ...config.cookie\n  });\n  return Promise.resolve();\n}\n\nfunction formatEventStreamMessage(message) {\n  let result = \"\";\n  if (message.id) {\n    result += `id: ${message.id}\n`;\n  }\n  if (message.event) {\n    result += `event: ${message.event}\n`;\n  }\n  if (typeof message.retry === \"number\" && Number.isInteger(message.retry)) {\n    result += `retry: ${message.retry}\n`;\n  }\n  result += `data: ${message.data}\n\n`;\n  return result;\n}\nfunction formatEventStreamMessages(messages) {\n  let result = \"\";\n  for (const msg of messages) {\n    result += formatEventStreamMessage(msg);\n  }\n  return result;\n}\nfunction setEventStreamHeaders(event) {\n  const headers = {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"private, no-cache, no-store, no-transform, must-revalidate, max-age=0\",\n    \"X-Accel-Buffering\": \"no\"\n    // prevent nginx from buffering the response\n  };\n  if (!isHttp2Request(event)) {\n    headers.Connection = \"keep-alive\";\n  }\n  setResponseHeaders(event, headers);\n}\nfunction isHttp2Request(event) {\n  return getHeader(event, \":path\") !== void 0 && getHeader(event, \":method\") !== void 0;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventStream {\n  constructor(event, opts = {}) {\n    __publicField$1(this, \"_h3Event\");\n    __publicField$1(this, \"_transformStream\", new TransformStream());\n    __publicField$1(this, \"_writer\");\n    __publicField$1(this, \"_encoder\", new TextEncoder());\n    __publicField$1(this, \"_writerIsClosed\", false);\n    __publicField$1(this, \"_paused\", false);\n    __publicField$1(this, \"_unsentData\");\n    __publicField$1(this, \"_disposed\", false);\n    __publicField$1(this, \"_handled\", false);\n    this._h3Event = event;\n    this._writer = this._transformStream.writable.getWriter();\n    this._writer.closed.then(() => {\n      this._writerIsClosed = true;\n    });\n    if (opts.autoclose !== false) {\n      this._h3Event.node.req.on(\"close\", () => this.close());\n    }\n  }\n  async push(message) {\n    if (typeof message === \"string\") {\n      await this._sendEvent({ data: message });\n      return;\n    }\n    if (Array.isArray(message)) {\n      if (message.length === 0) {\n        return;\n      }\n      if (typeof message[0] === \"string\") {\n        const msgs = [];\n        for (const item of message) {\n          msgs.push({ data: item });\n        }\n        await this._sendEvents(msgs);\n        return;\n      }\n      await this._sendEvents(message);\n      return;\n    }\n    await this._sendEvent(message);\n  }\n  async _sendEvent(message) {\n    if (this._writerIsClosed) {\n      return;\n    }\n    if (this._paused && !this._unsentData) {\n      this._unsentData = formatEventStreamMessage(message);\n      return;\n    }\n    if (this._paused) {\n      this._unsentData += formatEventStreamMessage(message);\n      return;\n    }\n    await this._writer.write(this._encoder.encode(formatEventStreamMessage(message))).catch();\n  }\n  async _sendEvents(messages) {\n    if (this._writerIsClosed) {\n      return;\n    }\n    const payload = formatEventStreamMessages(messages);\n    if (this._paused && !this._unsentData) {\n      this._unsentData = payload;\n      return;\n    }\n    if (this._paused) {\n      this._unsentData += payload;\n      return;\n    }\n    await this._writer.write(this._encoder.encode(payload)).catch();\n  }\n  pause() {\n    this._paused = true;\n  }\n  get isPaused() {\n    return this._paused;\n  }\n  async resume() {\n    this._paused = false;\n    await this.flush();\n  }\n  async flush() {\n    if (this._writerIsClosed) {\n      return;\n    }\n    if (this._unsentData?.length) {\n      await this._writer.write(this._encoder.encode(this._unsentData));\n      this._unsentData = void 0;\n    }\n  }\n  /**\n   * Close the stream and the connection if the stream is being sent to the client\n   */\n  async close() {\n    if (this._disposed) {\n      return;\n    }\n    if (!this._writerIsClosed) {\n      try {\n        await this._writer.close();\n      } catch {\n      }\n    }\n    if (this._h3Event._handled && this._handled && !this._h3Event.node.res.closed) {\n      this._h3Event.node.res.end();\n    }\n    this._disposed = true;\n  }\n  /**\n   * Triggers callback when the writable stream is closed.\n   * It is also triggered after calling the `close()` method.\n   */\n  onClosed(cb) {\n    this._writer.closed.then(cb);\n  }\n  async send() {\n    setEventStreamHeaders(this._h3Event);\n    setResponseStatus(this._h3Event, 200);\n    this._h3Event._handled = true;\n    this._handled = true;\n    await sendStream(this._h3Event, this._transformStream.readable);\n  }\n}\n\nfunction createEventStream(event, opts) {\n  return new EventStream(event, opts);\n}\n\nasync function serveStatic(event, options) {\n  if (event.method !== \"GET\" && event.method !== \"HEAD\") {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Method Not Allowed\",\n        statusCode: 405\n      });\n    }\n    return false;\n  }\n  const originalId = decodePath(\n    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))\n  );\n  const acceptEncodings = parseAcceptEncoding(\n    getRequestHeader(event, \"accept-encoding\"),\n    options.encodings\n  );\n  if (acceptEncodings.length > 1) {\n    setResponseHeader(event, \"vary\", \"accept-encoding\");\n  }\n  let id = originalId;\n  let meta;\n  const _ids = idSearchPaths(\n    originalId,\n    acceptEncodings,\n    options.indexNames || [\"/index.html\"]\n  );\n  for (const _id of _ids) {\n    const _meta = await options.getMeta(_id);\n    if (_meta) {\n      meta = _meta;\n      id = _id;\n      break;\n    }\n  }\n  if (!meta) {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Cannot find static asset \" + id,\n        statusCode: 404\n      });\n    }\n    return false;\n  }\n  if (meta.etag && !getResponseHeader(event, \"etag\")) {\n    setResponseHeader(event, \"etag\", meta.etag);\n  }\n  const ifNotMatch = meta.etag && getRequestHeader(event, \"if-none-match\") === meta.etag;\n  if (ifNotMatch) {\n    setResponseStatus(event, 304, \"Not Modified\");\n    return send(event, \"\");\n  }\n  if (meta.mtime) {\n    const mtimeDate = new Date(meta.mtime);\n    const ifModifiedSinceH = getRequestHeader(event, \"if-modified-since\");\n    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {\n      setResponseStatus(event, 304, \"Not Modified\");\n      return send(event, null);\n    }\n    if (!getResponseHeader(event, \"last-modified\")) {\n      setResponseHeader(event, \"last-modified\", mtimeDate.toUTCString());\n    }\n  }\n  if (meta.type && !getResponseHeader(event, \"content-type\")) {\n    setResponseHeader(event, \"content-type\", meta.type);\n  }\n  if (meta.encoding && !getResponseHeader(event, \"content-encoding\")) {\n    setResponseHeader(event, \"content-encoding\", meta.encoding);\n  }\n  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, \"content-length\")) {\n    setResponseHeader(event, \"content-length\", meta.size);\n  }\n  if (event.method === \"HEAD\") {\n    return send(event, null);\n  }\n  const contents = await options.getContents(id);\n  return isStream(contents) ? sendStream(event, contents) : send(event, contents);\n}\nfunction parseAcceptEncoding(header, encodingMap) {\n  if (!encodingMap || !header) {\n    return [];\n  }\n  return String(header || \"\").split(\",\").map((e) => encodingMap[e.trim()]).filter(Boolean);\n}\nfunction idSearchPaths(id, encodings, indexNames) {\n  const ids = [];\n  for (const suffix of [\"\", ...indexNames]) {\n    for (const encoding of [...encodings, \"\"]) {\n      ids.push(`${id}${suffix}${encoding}`);\n    }\n  }\n  return ids;\n}\n\nfunction defineWebSocket(hooks) {\n  return hooks;\n}\nfunction defineWebSocketHandler(hooks) {\n  return defineEventHandler({\n    handler() {\n      throw createError({\n        statusCode: 426,\n        statusMessage: \"Upgrade Required\"\n      });\n    },\n    websocket: hooks\n  });\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Event {\n  constructor(req, res) {\n    __publicField(this, \"__is_event__\", true);\n    // Context\n    __publicField(this, \"node\");\n    // Node\n    __publicField(this, \"web\");\n    // Web\n    __publicField(this, \"context\", {});\n    // Shared\n    // Request\n    __publicField(this, \"_method\");\n    __publicField(this, \"_path\");\n    __publicField(this, \"_headers\");\n    __publicField(this, \"_requestBody\");\n    // Response\n    __publicField(this, \"_handled\", false);\n    // Hooks\n    __publicField(this, \"_onBeforeResponseCalled\");\n    __publicField(this, \"_onAfterResponseCalled\");\n    this.node = { req, res };\n  }\n  // --- Request ---\n  get method() {\n    if (!this._method) {\n      this._method = (this.node.req.method || \"GET\").toUpperCase();\n    }\n    return this._method;\n  }\n  get path() {\n    return this._path || this.node.req.url || \"/\";\n  }\n  get headers() {\n    if (!this._headers) {\n      this._headers = _normalizeNodeHeaders(this.node.req.headers);\n    }\n    return this._headers;\n  }\n  // --- Respoonse ---\n  get handled() {\n    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;\n  }\n  respondWith(response) {\n    return Promise.resolve(response).then(\n      (_response) => sendWebResponse(this, _response)\n    );\n  }\n  // --- Utils ---\n  toString() {\n    return `[${this.method}] ${this.path}`;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  // --- Deprecated ---\n  /** @deprecated Please use `event.node.req` instead. */\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. */\n  get res() {\n    return this.node.res;\n  }\n}\nfunction isEvent(input) {\n  return hasProp(input, \"__is_event__\");\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\nfunction _normalizeNodeHeaders(nodeHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of Object.entries(nodeHeaders)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        headers.append(name, item);\n      }\n    } else if (value) {\n      headers.set(name, value);\n    }\n  }\n  return headers;\n}\n\nfunction defineEventHandler(handler) {\n  if (typeof handler === \"function\") {\n    handler.__is_handler__ = true;\n    return handler;\n  }\n  const _hooks = {\n    onRequest: _normalizeArray(handler.onRequest),\n    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)\n  };\n  const _handler = (event) => {\n    return _callHandler(event, handler.handler, _hooks);\n  };\n  _handler.__is_handler__ = true;\n  _handler.__resolve__ = handler.handler.__resolve__;\n  _handler.__websocket__ = handler.websocket;\n  return _handler;\n}\nfunction _normalizeArray(input) {\n  return input ? Array.isArray(input) ? input : [input] : void 0;\n}\nasync function _callHandler(event, handler, hooks) {\n  if (hooks.onRequest) {\n    for (const hook of hooks.onRequest) {\n      await hook(event);\n      if (event.handled) {\n        return;\n      }\n    }\n  }\n  const body = await handler(event);\n  const response = { body };\n  if (hooks.onBeforeResponse) {\n    for (const hook of hooks.onBeforeResponse) {\n      await hook(event, response);\n    }\n  }\n  return response.body;\n}\nconst eventHandler = defineEventHandler;\nfunction defineRequestMiddleware(fn) {\n  return fn;\n}\nfunction defineResponseMiddleware(fn) {\n  return fn;\n}\nfunction isEventHandler(input) {\n  return hasProp(input, \"__is_handler__\");\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler2 = r.default || r;\n        if (typeof handler2 !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler2\n          );\n        }\n        _resolved = { handler: toEventHandler(r.default || r) };\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  const handler = eventHandler((event) => {\n    if (_resolved) {\n      return _resolved.handler(event);\n    }\n    return resolveHandler().then((r) => r.handler(event));\n  });\n  handler.__resolve__ = resolveHandler;\n  return handler;\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nconst H3Headers = globalThis.Headers;\nconst H3Response = globalThis.Response;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const resolve = createResolver(stack);\n  handler.__resolve__ = resolve;\n  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));\n  const app = {\n    // @ts-expect-error\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    resolve,\n    handler,\n    stack,\n    options,\n    get websocket() {\n      return getWebsocket();\n    }\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _reqPath = event._path || event.node.req.url || \"/\";\n    let _layerPath;\n    if (options.onRequest) {\n      await options.onRequest(event);\n    }\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!_reqPath.startsWith(layer.route)) {\n          continue;\n        }\n        _layerPath = _reqPath.slice(layer.route.length) || \"/\";\n      } else {\n        _layerPath = _reqPath;\n      }\n      if (layer.match && !layer.match(_layerPath, event)) {\n        continue;\n      }\n      event._path = _layerPath;\n      event.node.req.url = _layerPath;\n      const val = await layer.handler(event);\n      const _body = val === void 0 ? void 0 : await val;\n      if (_body !== void 0) {\n        const _response = { body: _body };\n        if (options.onBeforeResponse) {\n          event._onBeforeResponseCalled = true;\n          await options.onBeforeResponse(event, _response);\n        }\n        await handleHandlerResponse(event, _response.body, spacing);\n        if (options.onAfterResponse) {\n          event._onAfterResponseCalled = true;\n          await options.onAfterResponse(event, _response);\n        }\n        return;\n      }\n      if (event.handled) {\n        if (options.onAfterResponse) {\n          event._onAfterResponseCalled = true;\n          await options.onAfterResponse(event, void 0);\n        }\n        return;\n      }\n    }\n    if (!event.handled) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any path matching ${event.path || \"/\"}.`\n      });\n    }\n    if (options.onAfterResponse) {\n      event._onAfterResponseCalled = true;\n      await options.onAfterResponse(event, void 0);\n    }\n  });\n}\nfunction createResolver(stack) {\n  return async (path) => {\n    let _layerPath;\n    for (const layer of stack) {\n      if (layer.route === \"/\" && !layer.handler.__resolve__) {\n        continue;\n      }\n      if (!path.startsWith(layer.route)) {\n        continue;\n      }\n      _layerPath = path.slice(layer.route.length) || \"/\";\n      if (layer.match && !layer.match(_layerPath, void 0)) {\n        continue;\n      }\n      let res = { route: layer.route, handler: layer.handler };\n      if (res.handler.__resolve__) {\n        const _res = await res.handler.__resolve__(_layerPath);\n        if (!_res) {\n          continue;\n        }\n        res = {\n          ...res,\n          ..._res,\n          route: joinURL(res.route || \"/\", _res.route || \"/\")\n        };\n      }\n      return res;\n    }\n  };\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\nfunction handleHandlerResponse(event, val, jsonSpace) {\n  if (val === null) {\n    return sendNoContent(event);\n  }\n  if (val) {\n    if (isWebResponse(val)) {\n      return sendWebResponse(event, val);\n    }\n    if (isStream(val)) {\n      return sendStream(event, val);\n    }\n    if (val.buffer) {\n      return send(event, val);\n    }\n    if (val.arrayBuffer && typeof val.arrayBuffer === \"function\") {\n      return val.arrayBuffer().then((arrayBuffer) => {\n        return send(event, Buffer.from(arrayBuffer), val.type);\n      });\n    }\n    if (val instanceof Error) {\n      throw createError(val);\n    }\n    if (typeof val.end === \"function\") {\n      return true;\n    }\n  }\n  const valType = typeof val;\n  if (valType === \"string\") {\n    return send(event, val, MIMES.html);\n  }\n  if (valType === \"object\" || valType === \"boolean\" || valType === \"number\") {\n    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);\n  }\n  if (valType === \"bigint\") {\n    return send(event, val.toString(), MIMES.json);\n  }\n  throw createError({\n    statusCode: 500,\n    statusMessage: `[h3] Cannot send ${valType} as response.`\n  });\n}\nfunction cachedFn(fn) {\n  let cache;\n  return () => {\n    if (!cache) {\n      cache = fn();\n    }\n    return cache;\n  };\n}\nfunction websocketOptions(evResolver, appOptions) {\n  return {\n    ...appOptions.websocket,\n    async resolve(info) {\n      const url = info.request?.url || info.url || \"/\";\n      const { pathname } = typeof url === \"string\" ? parseURL(url) : url;\n      const resolved = await evResolver(pathname);\n      return resolved?.handler?.__websocket__ || {};\n    }\n  };\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  let _matcher;\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { path, handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  const matchHandler = (path = \"/\", method = \"get\") => {\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      return {\n        error: createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${path || \"/\"}.`\n        })\n      };\n    }\n    let handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      if (!_matcher) {\n        _matcher = toRouteMatcher(_router);\n      }\n      const _matches = _matcher.matchAll(path).reverse();\n      for (const _match of _matches) {\n        if (_match.handlers[method]) {\n          handler = _match.handlers[method];\n          matched.handlers[method] = matched.handlers[method] || handler;\n          break;\n        }\n        if (_match.handlers.all) {\n          handler = _match.handlers.all;\n          matched.handlers.all = matched.handlers.all || handler;\n          break;\n        }\n      }\n    }\n    if (!handler) {\n      return {\n        error: createError({\n          statusCode: 405,\n          name: \"Method Not Allowed\",\n          statusMessage: `Method ${method} is not allowed on this route.`\n        })\n      };\n    }\n    return { matched, handler };\n  };\n  const isPreemptive = opts.preemptive || opts.preemtive;\n  router.handler = eventHandler((event) => {\n    const match = matchHandler(\n      event.path,\n      event.method.toLowerCase()\n    );\n    if (\"error\" in match) {\n      if (isPreemptive) {\n        throw match.error;\n      } else {\n        return;\n      }\n    }\n    event.context.matchedRoute = match.matched;\n    const params = match.matched.params || {};\n    event.context.params = params;\n    return Promise.resolve(match.handler(event)).then((res) => {\n      if (res === void 0 && isPreemptive) {\n        return null;\n      }\n      return res;\n    });\n  });\n  router.handler.__resolve__ = async (path) => {\n    path = withLeadingSlash(path);\n    const match = matchHandler(path);\n    if (\"error\" in match) {\n      return;\n    }\n    let res = {\n      route: match.matched.path,\n      handler: match.handler\n    };\n    if (match.handler.__resolve__) {\n      const _res = await match.handler.__resolve__(path);\n      if (!_res) {\n        return;\n      }\n      res = { ...res, ..._res };\n    }\n    return res;\n  };\n  return router;\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      setResponseStatus(event, error.statusCode, error.statusMessage);\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      }\n      if (event.handled) {\n        return;\n      }\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {\n        await app.options.onBeforeResponse(event, { body: error });\n      }\n      await sendError(event, error, !!app.options.debug);\n      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {\n        await app.options.onAfterResponse(event, { body: error });\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nfunction toPlainHandler(app) {\n  const handler = (request) => {\n    return _handlePlainRequest(app, request);\n  };\n  return handler;\n}\nfunction fromPlainHandler(handler) {\n  return eventHandler(async (event) => {\n    const res = await handler({\n      method: event.method,\n      path: event.path,\n      headers: Object.fromEntries(event.headers.entries()),\n      body: getRequestWebStream(event),\n      context: event.context\n    });\n    setResponseStatus(event, res.status, res.statusText);\n    for (const [key, value] of res.headers) {\n      setResponseHeader(event, key, value);\n    }\n    return res.body;\n  });\n}\nasync function _handlePlainRequest(app, request) {\n  const path = request.path;\n  const method = (request.method || \"GET\").toUpperCase();\n  const headers = new Headers(request.headers);\n  const nodeReq = new IncomingMessage();\n  const nodeRes = new ServerResponse(nodeReq);\n  nodeReq.method = method;\n  nodeReq.url = path;\n  nodeReq.headers = Object.fromEntries(headers.entries());\n  const event = createEvent(nodeReq, nodeRes);\n  event._method = method;\n  event._path = path;\n  event._headers = headers;\n  if (request.body) {\n    event._requestBody = request.body;\n  }\n  if (request._eventOverrides) {\n    Object.assign(event, request._eventOverrides);\n  }\n  if (request.context) {\n    Object.assign(event.context, request.context);\n  }\n  try {\n    await app.handler(event);\n  } catch (_error) {\n    const error = createError(_error);\n    if (!isError(_error)) {\n      error.unhandled = true;\n    }\n    if (app.options.onError) {\n      await app.options.onError(error, event);\n    }\n    if (!event.handled) {\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  }\n  return {\n    status: nodeRes.statusCode,\n    statusText: nodeRes.statusMessage,\n    headers: _normalizeUnenvHeaders(nodeRes._headers),\n    body: nodeRes._data\n  };\n}\nfunction _normalizeUnenvHeaders(input) {\n  const headers = [];\n  const cookies = [];\n  for (const _key in input) {\n    const key = _key.toLowerCase();\n    if (key === \"set-cookie\") {\n      cookies.push(\n        ...splitCookiesString(input[\"set-cookie\"])\n      );\n      continue;\n    }\n    const value = input[key];\n    if (Array.isArray(value)) {\n      for (const _value of value) {\n        headers.push([key, _value]);\n      }\n    } else if (value !== void 0) {\n      headers.push([key, String(value)]);\n    }\n  }\n  if (cookies.length > 0) {\n    for (const cookie of cookies) {\n      headers.push([\"set-cookie\", cookie]);\n    }\n  }\n  return headers;\n}\n\nfunction toWebHandler(app) {\n  const webHandler = (request, context) => {\n    return _handleWebRequest(app, request, context);\n  };\n  return webHandler;\n}\nfunction fromWebHandler(handler) {\n  return eventHandler((event) => handler(toWebRequest(event), event.context));\n}\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nasync function _handleWebRequest(app, request, context) {\n  const url = new URL(request.url);\n  const res = await _handlePlainRequest(app, {\n    _eventOverrides: {\n      web: { request, url }\n    },\n    context,\n    method: request.method,\n    path: url.pathname + url.search,\n    headers: request.headers,\n    body: request.body\n  });\n  const body = nullBodyResponses.has(res.status) || request.method === \"HEAD\" ? null : res.body;\n  return new Response(body, {\n    status: res.status,\n    statusText: res.statusText,\n    headers: res.headers\n  });\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearResponseHeaders, clearSession, createApp, createAppEventHandler, createError, createEvent, createEventStream, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, defineRequestMiddleware, defineResponseMiddleware, defineWebSocket, defineWebSocketHandler, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, fromPlainHandler, fromWebHandler, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestFingerprint, getRequestHeader, getRequestHeaders, getRequestHost, getRequestIP, getRequestPath, getRequestProtocol, getRequestURL, getRequestWebStream, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, getValidatedQuery, getValidatedRouterParams, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, isWebResponse, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readFormData, readMultipartFormData, readRawBody, readValidatedBody, removeResponseHeader, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendIterable, sendNoContent, sendProxy, sendRedirect, sendStream, sendWebResponse, serveStatic, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, toPlainHandler, toWebHandler, toWebRequest, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\n","function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce(\n    (promise, task) => promise.then(() => function_(task)),\n    Promise.resolve()\n  );\n}\nconst defaultTask = { run: (function_) => function_() };\nconst _createTask = () => defaultTask;\nconst createTask = typeof console.createTask !== \"undefined\" ? console.createTask : _createTask;\nfunction serialTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),\n    Promise.resolve()\n  );\n}\nfunction parallelTaskCaller(hooks, args) {\n  const name = args.shift();\n  const task = createTask(name);\n  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce(\n    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),\n    Promise.resolve()\n  );\n}\nfunction parallelCaller(hooks, args) {\n  return Promise.all(hooks.map((hook) => hook(...args || [])));\n}\nfunction callEachWith(callbacks, arg0) {\n  for (const callback of [...callbacks]) {\n    callback(arg0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    if (!function_.name) {\n      try {\n        Object.defineProperty(function_, \"name\", {\n          get: () => \"_\" + name.replace(/\\W+/g, \"_\") + \"_hook_cb\",\n          configurable: true\n        });\n      } catch {\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    delete this._hooks[name];\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map(\n      (key) => this.hook(key, hooks[key])\n    );\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  removeAllHooks() {\n    for (const key in this._hooks) {\n      delete this._hooks[key];\n    }\n  }\n  callHook(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(serialTaskCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    arguments_.unshift(name);\n    return this.callHookWith(parallelTaskCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(\n      name in this._hooks ? [...this._hooks[name]] : [],\n      arguments_\n    );\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      if (this._before !== void 0) {\n        const index = this._before.indexOf(function_);\n        if (index !== -1) {\n          this._before.splice(index, 1);\n        }\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      if (this._after !== void 0) {\n        const index = this._after.indexOf(function_);\n        if (index !== -1) {\n          this._after.splice(index, 1);\n        }\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (filter !== void 0 && !filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    /** Stop debugging and remove listeners */\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n","const e=globalThis.Blob,o=globalThis.File,a=globalThis.FormData,s=globalThis.Headers,t=globalThis.Request,h=globalThis.Response,i=globalThis.AbortController,l=globalThis.fetch||(()=>{throw new Error(\"[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!\")});export{i as AbortController,e as Blob,o as File,a as FormData,s as Headers,t as Request,h as Response,l as default,l as fetch};\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction resolveFetchOptions(request, input, defaults, Headers) {\n  const headers = mergeHeaders(\n    input?.headers ?? request?.headers,\n    defaults?.headers,\n    Headers\n  );\n  let query;\n  if (defaults?.query || defaults?.params || input?.params || input?.query) {\n    query = {\n      ...defaults?.params,\n      ...defaults?.query,\n      ...input?.params,\n      ...input?.query\n    };\n  }\n  return {\n    ...defaults,\n    ...input,\n    query,\n    params: query,\n    headers\n  };\n}\nfunction mergeHeaders(input, defaults, Headers) {\n  if (!defaults) {\n    return new Headers(input);\n  }\n  const headers = new Headers(defaults);\n  if (input) {\n    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {\n      headers.set(key, value);\n    }\n  }\n  return headers;\n}\nasync function callHooks(context, hooks) {\n  if (hooks) {\n    if (Array.isArray(hooks)) {\n      for (const hook of hooks) {\n        await hook(context);\n      }\n    } else {\n      await hooks(context);\n    }\n  }\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early (Experimental)\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  // Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = typeof context.options.retryDelay === \"function\" ? context.options.retryDelay(context) : context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: resolveFetchOptions(\n        _request,\n        _options,\n        globalOptions.defaults,\n        Headers\n      ),\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.method) {\n      context.options.method = context.options.method.toUpperCase();\n    }\n    if (context.options.onRequest) {\n      await callHooks(context, context.options.onRequest);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query) {\n        context.request = withQuery(context.request, context.options.query);\n        delete context.options.query;\n      }\n      if (\"query\" in context.options) {\n        delete context.options.query;\n      }\n      if (\"params\" in context.options) {\n        delete context.options.params;\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    let abortTimeout;\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      abortTimeout = setTimeout(() => {\n        const error = new Error(\n          \"[TimeoutError]: The operation was aborted due to timeout\"\n        );\n        error.name = \"TimeoutError\";\n        error.code = 23;\n        controller.abort(error);\n      }, context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await callHooks(\n          context,\n          context.options.onRequestError\n        );\n      }\n      return await onError(context);\n    } finally {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324\n    // https://github.com/unjs/ofetch/issues/294\n    // https://github.com/JakeChampion/fetch/issues/1454\n    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr;\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body || context.response._bodyInit;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await callHooks(\n        context,\n        context.options.onResponse\n      );\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await callHooks(\n          context,\n          context.options.onResponseError\n        );\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({\n    ...globalOptions,\n    ...customGlobalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...customGlobalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import http from 'node:http';\nimport https from 'node:https';\nimport nodeFetch, { Headers as Headers$1, AbortController as AbortController$1 } from 'node-fetch-native';\nimport { c as createFetch } from './shared/ofetch.03887fc3.mjs';\nexport { F as FetchError, a as createFetchError } from './shared/ofetch.03887fc3.mjs';\nimport 'destr';\nimport 'ufo';\n\nfunction createNodeFetch() {\n  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || \"false\");\n  if (!useKeepAlive) {\n    return nodeFetch;\n  }\n  const agentOptions = { keepAlive: true };\n  const httpAgent = new http.Agent(agentOptions);\n  const httpsAgent = new https.Agent(agentOptions);\n  const nodeFetchOptions = {\n    agent(parsedURL) {\n      return parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent;\n    }\n  };\n  return function nodeFetchWithKeepAlive(input, init) {\n    return nodeFetch(input, { ...nodeFetchOptions, ...init });\n  };\n}\nconst fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();\nconst Headers = globalThis.Headers || Headers$1;\nconst AbortController = globalThis.AbortController || AbortController$1;\nconst ofetch = createFetch({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\nexport { $fetch, AbortController, Headers, createFetch, createNodeFetch, fetch, ofetch };\n","import { IncomingMessage } from \"../node/http/_request.mjs\";\nimport { ServerResponse } from \"../node/http/_response.mjs\";\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nexport function createCall(handle) {\n  return function callHandle(context) {\n    const req = new IncomingMessage();\n    const res = new ServerResponse(req);\n    req.url = context.url || \"/\";\n    req.method = context.method || \"GET\";\n    req.headers = {};\n    if (context.headers) {\n      const headerEntries = typeof context.headers.entries === \"function\" ? context.headers.entries() : Object.entries(context.headers);\n      for (const [name, value] of headerEntries) {\n        if (!value) {\n          continue;\n        }\n        req.headers[name.toLowerCase()] = value;\n      }\n    }\n    req.headers.host = req.headers.host || context.host || \"localhost\";\n    req.connection.encrypted = // @ts-ignore\n    req.connection.encrypted || context.protocol === \"https\";\n    req.body = context.body || null;\n    req.__unenv__ = context.context;\n    return handle(req, res).then(() => {\n      let body = res._data;\n      if (nullBodyResponses.has(res.statusCode) || req.method.toUpperCase() === \"HEAD\") {\n        body = null;\n        delete res._headers[\"content-length\"];\n      }\n      const r = {\n        body,\n        headers: res._headers,\n        status: res.statusCode,\n        statusText: res.statusMessage\n      };\n      req.destroy();\n      res.destroy();\n      return r;\n    });\n  };\n}\n","export * from \"./call.mjs\";\nexport function createFetch(call, _fetch = global.fetch) {\n  return async function ufetch(input, init) {\n    const url = input.toString();\n    if (!url.startsWith(\"/\")) {\n      return _fetch(url, init);\n    }\n    try {\n      const r = await call({ url, ...init });\n      return new Response(r.body, {\n        status: r.status,\n        statusText: r.statusText,\n        headers: Object.fromEntries(\n          Object.entries(r.headers).map(([name, value]) => [\n            name,\n            Array.isArray(value) ? value.join(\",\") : String(value) || \"\"\n          ])\n        )\n      });\n    } catch (error) {\n      return new Response(error.toString(), {\n        status: Number.parseInt(error.statusCode || error.code) || 500,\n        statusText: error.statusText\n      });\n    }\n  };\n}\n","import { getRequestHeader, splitCookiesString } from \"h3\";\nimport { useNitroApp } from \"./app.mjs\";\nconst METHOD_WITH_BODY_RE = /post|put|patch/i;\nconst TEXT_MIME_RE = /application\\/text|text\\/html/;\nconst JSON_MIME_RE = /application\\/json/;\nexport function requestHasBody(request) {\n  return METHOD_WITH_BODY_RE.test(request.method);\n}\nexport async function useRequestBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (contentType.includes(\"form\")) {\n    const formData = await request.formData();\n    const body = /* @__PURE__ */ Object.create(null);\n    for (const entry of formData.entries()) {\n      body[entry[0]] = entry[1];\n    }\n    return body;\n  }\n  if (JSON_MIME_RE.test(contentType)) {\n    return request.json();\n  }\n  if (TEXT_MIME_RE.test(contentType)) {\n    return request.text();\n  }\n  const blob = await request.blob();\n  return URL.createObjectURL(blob);\n}\nexport function hasReqHeader(event, name, includes) {\n  const value = getRequestHeader(event, name);\n  return value && typeof value === \"string\" && value.toLowerCase().includes(includes);\n}\nexport function isJsonRequest(event) {\n  if (hasReqHeader(event, \"accept\", \"text/html\")) {\n    return false;\n  }\n  return hasReqHeader(event, \"accept\", \"application/json\") || hasReqHeader(event, \"user-agent\", \"curl/\") || hasReqHeader(event, \"user-agent\", \"httpie/\") || hasReqHeader(event, \"sec-fetch-mode\", \"cors\") || event.path.startsWith(\"/api/\") || event.path.endsWith(\".json\");\n}\nexport function normalizeError(error, isDev) {\n  const cwd = typeof process.cwd === \"function\" ? process.cwd() : \"/\";\n  const stack = !isDev && !import.meta.prerender && (error.unhandled || error.fatal) ? [] : (error.stack || \"\").split(\"\\n\").splice(1).filter((line) => line.includes(\"at \")).map((line) => {\n    const text = line.replace(cwd + \"/\", \"./\").replace(\"webpack:/\", \"\").replace(\"file://\", \"\").trim();\n    return {\n      text,\n      internal: line.includes(\"node_modules\") && !line.includes(\".cache\") || line.includes(\"internal\") || line.includes(\"new Promise\")\n    };\n  });\n  const statusCode = error.statusCode || 500;\n  const statusMessage = error.statusMessage ?? (statusCode === 404 ? \"Not Found\" : \"\");\n  const message = !isDev && error.unhandled ? \"internal server error\" : error.message || error.toString();\n  return {\n    stack,\n    statusCode,\n    statusMessage,\n    message\n  };\n}\nfunction _captureError(error, type) {\n  console.error(`[nitro] [${type}]`, error);\n  useNitroApp().captureError(error, { tags: [type] });\n}\nexport function trapUnhandledNodeErrors() {\n  process.on(\n    \"unhandledRejection\",\n    (error) => _captureError(error, \"unhandledRejection\")\n  );\n  process.on(\n    \"uncaughtException\",\n    (error) => _captureError(error, \"uncaughtException\")\n  );\n}\nexport function joinHeaders(value) {\n  return Array.isArray(value) ? value.join(\", \") : String(value);\n}\nexport function normalizeFetchResponse(response) {\n  if (!response.headers.has(\"set-cookie\")) {\n    return response;\n  }\n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers: normalizeCookieHeaders(response.headers)\n  });\n}\nexport function normalizeCookieHeader(header = \"\") {\n  return splitCookiesString(joinHeaders(header));\n}\nexport function normalizeCookieHeaders(headers) {\n  const outgoingHeaders = new Headers();\n  for (const [name, header] of headers) {\n    if (name === \"set-cookie\") {\n      for (const cookie of normalizeCookieHeader(header)) {\n        outgoingHeaders.append(\"set-cookie\", cookie);\n      }\n    } else {\n      outgoingHeaders.set(name, joinHeaders(header));\n    }\n  }\n  return outgoingHeaders;\n}\nexport function toBuffer(data) {\n  if (\"pipeTo\" in data && typeof data.pipeTo === \"function\") {\n    return new Promise((resolve, reject) => {\n      const chunks = [];\n      data.pipeTo(\n        new WritableStream({\n          write(chunk) {\n            chunks.push(chunk);\n          },\n          close() {\n            resolve(Buffer.concat(chunks));\n          },\n          abort(reason) {\n            reject(reason);\n          }\n        })\n      ).catch(reject);\n    });\n  }\n  if (\"pipe\" in data && typeof data.pipe === \"function\") {\n    return new Promise((resolve, reject) => {\n      const chunks = [];\n      data.on(\"data\", (chunk) => {\n        chunks.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(chunks));\n      }).on(\"error\", reject);\n    });\n  }\n  return Buffer.from(data);\n}\n","import { joinURL, withQuery } from \"ufo\";\nimport { getRequestHeaders, send, setResponseHeader, setResponseStatus } from \"h3\";\nimport { useRuntimeConfig } from \"#internal/nitro\";\nimport { useNitroApp } from \"#internal/nitro/app\";\nimport { isJsonRequest, normalizeError } from \"#internal/nitro/utils\";\nexport default (async function errorhandler(error, event) {\n  const { stack, statusCode, statusMessage, message } = normalizeError(error);\n  const errorObject = {\n    url: event.path,\n    statusCode,\n    statusMessage,\n    message,\n    stack: import.meta.dev && statusCode !== 404 ? `<pre>${stack.map((i) => `<span class=\"stack${i.internal ? \" internal\" : \"\"}\">${i.text}</span>`).join(\"\\n\")}</pre>` : \"\",\n    // TODO: check and validate error.data for serialisation into query\n    data: error.data\n  };\n  if (error.unhandled || error.fatal) {\n    const tags = [\n      \"[nuxt]\",\n      \"[request error]\",\n      error.unhandled && \"[unhandled]\",\n      error.fatal && \"[fatal]\",\n      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`\n    ].filter(Boolean).join(\" \");\n    console.error(tags, (error.message || error.toString() || \"internal server error\") + \"\\n\" + stack.map((l) => \"  \" + l.text).join(\"  \\n\"));\n  }\n  if (event.handled) {\n    return;\n  }\n  setResponseStatus(event, errorObject.statusCode !== 200 && errorObject.statusCode || 500, errorObject.statusMessage);\n  if (isJsonRequest(event)) {\n    setResponseHeader(event, \"Content-Type\", \"application/json\");\n    return send(event, JSON.stringify(errorObject));\n  }\n  const reqHeaders = getRequestHeaders(event);\n  const isRenderingError = event.path.startsWith(\"/__nuxt_error\") || !!reqHeaders[\"x-nuxt-error\"];\n  const res = isRenderingError ? null : await useNitroApp().localFetch(\n    withQuery(joinURL(useRuntimeConfig(event).app.baseURL, \"/__nuxt_error\"), errorObject),\n    {\n      headers: { ...reqHeaders, \"x-nuxt-error\": \"true\" },\n      redirect: \"manual\"\n    }\n  ).catch(() => null);\n  if (!res) {\n    const { template } = import.meta.dev ? await import(\"./error-dev\") : await import(\"./error-500\");\n    if (import.meta.dev) {\n      errorObject.description = errorObject.message;\n    }\n    if (event.handled) {\n      return;\n    }\n    setResponseHeader(event, \"Content-Type\", \"text/html;charset=UTF-8\");\n    return send(event, template(errorObject));\n  }\n  const html = await res.text();\n  if (event.handled) {\n    return;\n  }\n  for (const [header, value] of res.headers.entries()) {\n    setResponseHeader(event, header, value);\n  }\n  setResponseStatus(event, res.status && res.status !== 200 ? res.status : void 0, res.statusText);\n  return send(event, html);\n});\n","import { captureException, dropUndefinedKeys, getClient, getTraceMetaTags } from \"@sentry/core\";\nexport function extractErrorContext(errorContext) {\n  const structuredContext = {\n    method: void 0,\n    path: void 0,\n    tags: void 0\n  };\n  if (errorContext) {\n    if (errorContext.event) {\n      structuredContext.method = errorContext.event._method || void 0;\n      structuredContext.path = errorContext.event._path || void 0;\n    }\n    if (Array.isArray(errorContext.tags)) {\n      structuredContext.tags = errorContext.tags || void 0;\n    }\n  }\n  return dropUndefinedKeys(structuredContext);\n}\nexport function addSentryTracingMetaTags(head) {\n  const metaTags = getTraceMetaTags();\n  if (metaTags) {\n    head.push(metaTags);\n  }\n}\nexport function reportNuxtError(options) {\n  const { error, instance, info } = options;\n  const metadata = {\n    info\n    // todo: add component name and trace (like in the vue integration)\n  };\n  if (instance?.$props) {\n    const sentryClient = getClient();\n    const sentryOptions = sentryClient ? sentryClient.getOptions() : null;\n    if (sentryOptions?.attachProps && instance.$props !== false) {\n      metadata.propsData = instance.$props;\n    }\n  }\n  setTimeout(() => {\n    captureException(error, {\n      captureContext: { contexts: { nuxt: metadata } },\n      mechanism: { handled: false }\n    });\n  });\n}\n","import {\n  GLOBAL_OBJ,\n  flush,\n  getDefaultIsolationScope,\n  getIsolationScope,\n  logger,\n  vercelWaitUntil,\n  withIsolationScope\n} from \"@sentry/core\";\nimport * as SentryNode from \"@sentry/node\";\nimport { H3Error } from \"h3\";\nimport { defineNitroPlugin } from \"nitropack/runtime\";\nimport { addSentryTracingMetaTags, extractErrorContext } from \"../utils.js\";\nexport default defineNitroPlugin((nitroApp) => {\n  nitroApp.h3App.handler = patchEventHandler(nitroApp.h3App.handler);\n  nitroApp.hooks.hook(\"error\", async (error, errorContext) => {\n    const sentryClient = SentryNode.getClient();\n    const sentryClientOptions = sentryClient?.getOptions();\n    console.log(\"clientoptions::\", sentryClientOptions);\n    if (sentryClientOptions && \"enableNitroErrorHandler\" in sentryClientOptions && sentryClientOptions.enableNitroErrorHandler === false) {\n      return;\n    }\n    if (error instanceof H3Error) {\n      if (error.statusCode >= 300 && error.statusCode < 500) {\n        return;\n      }\n    }\n    const { method, path } = {\n      method: errorContext.event?._method ? errorContext.event._method : \"\",\n      path: errorContext.event?._path ? errorContext.event._path : null\n    };\n    if (path) {\n      SentryNode.getCurrentScope().setTransactionName(`${method} ${path}`);\n    }\n    const structuredContext = extractErrorContext(errorContext);\n    SentryNode.captureException(error, {\n      captureContext: { contexts: { nuxt: structuredContext } },\n      mechanism: { handled: false }\n    });\n    await flushIfServerless();\n  });\n  nitroApp.hooks.hook(\"render:html\", (html) => {\n    addSentryTracingMetaTags(html.head);\n  });\n});\nasync function flushIfServerless() {\n  const isServerless = !!process.env.FUNCTIONS_WORKER_RUNTIME || // Azure Functions\n  !!process.env.LAMBDA_TASK_ROOT || // AWS Lambda\n  !!process.env.VERCEL || !!process.env.NETLIFY;\n  if (GLOBAL_OBJ[Symbol.for(\"@vercel/request-context\")]) {\n    vercelWaitUntil(flushWithTimeout());\n  } else if (isServerless) {\n    await flushWithTimeout();\n  }\n}\nasync function flushWithTimeout() {\n  const sentryClient = SentryNode.getClient();\n  const isDebug = sentryClient ? sentryClient.getOptions().debug : false;\n  try {\n    isDebug && logger.log(\"Flushing events...\");\n    await flush(2e3);\n    isDebug && logger.log(\"Done flushing events\");\n  } catch (e) {\n    isDebug && logger.log(\"Error while flushing events:\\n\", e);\n  }\n}\nfunction patchEventHandler(handler) {\n  return new Proxy(handler, {\n    async apply(handlerTarget, handlerThisArg, handlerArgs) {\n      const isolationScope = getIsolationScope();\n      const newIsolationScope = isolationScope === getDefaultIsolationScope() ? isolationScope.clone() : isolationScope;\n      logger.log(\n        `Patched h3 event handler. ${isolationScope === newIsolationScope ? \"Using existing\" : \"Created new\"} isolation scope.`\n      );\n      return withIsolationScope(newIsolationScope, async () => {\n        try {\n          return await handlerTarget.apply(handlerThisArg, handlerArgs);\n        } finally {\n          await flushIfServerless();\n        }\n      });\n    }\n  });\n}\n","export function defineNitroPlugin(def) {\n  return def;\n}\nexport const nitroPlugin = defineNitroPlugin;\n","import { createDebugger } from \"hookable\";\nimport { defineNitroPlugin } from \"./plugin.mjs\";\nexport default defineNitroPlugin((nitro) => {\n  createDebugger(nitro.hooks, { tag: \"nitro-runtime\" });\n});\n","import { defineEventHandler, getRequestURL } from \"#imports\";\n\nexport default defineEventHandler((event) => {\n  console.log(\"New request: \" + getRequestURL(event));\n});\n","import { defineEventHandler, getRequestURL } from \"#imports\";\n\nexport default defineEventHandler((event) => {\n  console.log(\"New request: \" + getRequestURL(event));\n});\n","export function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar k, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\tif (x.constructor !== Object && typeof x.constructor === 'function') {\n\t\t\ttmp = new x.constructor();\n\t\t\tfor (k in x) {\n\t\t\t\tif (x.hasOwnProperty(k) && tmp[k] !== x[k]) {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = {}; // null\n\t\t\tfor (k in x) {\n\t\t\t\tif (k === '__proto__') {\n\t\t\t\t\tObject.defineProperty(tmp, k, {\n\t\t\t\t\t\tvalue: klona(x[k]),\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Array]') {\n\t\tk = x.length;\n\t\tfor (tmp=Array(k); k--;) {\n\t\t\ttmp[k] = klona(x[k]);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Date]') {\n\t\treturn new Date(+x);\n\t}\n\n\tif (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t\ttmp.lastIndex = x.lastIndex;\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object DataView]') {\n\t\treturn new x.constructor( klona(x.buffer) );\n\t}\n\n\tif (str === '[object ArrayBuffer]') {\n\t\treturn x.slice(0);\n\t}\n\n\t// ArrayBuffer.isView(x)\n\t// ~> `new` bcuz `Buffer.slice` => ref\n\tif (str.slice(-6) === 'Array]') {\n\t\treturn new x.constructor(x);\n\t}\n\n\treturn x;\n}\n","const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n  if (NUMBER_CHAR_RE.test(char)) {\n    return void 0;\n  }\n  return char !== char.toLowerCase();\n}\nfunction splitByCase(str, separators) {\n  const splitters = separators ?? STR_SPLITTERS;\n  const parts = [];\n  if (!str || typeof str !== \"string\") {\n    return parts;\n  }\n  let buff = \"\";\n  let previousUpper;\n  let previousSplitter;\n  for (const char of str) {\n    const isSplitter = splitters.includes(char);\n    if (isSplitter === true) {\n      parts.push(buff);\n      buff = \"\";\n      previousUpper = void 0;\n      continue;\n    }\n    const isUpper = isUppercase(char);\n    if (previousSplitter === false) {\n      if (previousUpper === false && isUpper === true) {\n        parts.push(buff);\n        buff = char;\n        previousUpper = isUpper;\n        continue;\n      }\n      if (previousUpper === true && isUpper === false && buff.length > 1) {\n        const lastChar = buff.at(-1);\n        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n        buff = lastChar + char;\n        previousUpper = isUpper;\n        continue;\n      }\n    }\n    buff += char;\n    previousUpper = isUpper;\n    previousSplitter = isSplitter;\n  }\n  parts.push(buff);\n  return parts;\n}\nfunction upperFirst(str) {\n  return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n  return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\nfunction pascalCase(str, opts) {\n  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => upperFirst(opts?.normalize ? p.toLowerCase() : p)).join(\"\") : \"\";\n}\nfunction camelCase(str, opts) {\n  return lowerFirst(pascalCase(str || \"\", opts));\n}\nfunction kebabCase(str, joiner) {\n  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join(joiner ?? \"-\") : \"\";\n}\nfunction snakeCase(str) {\n  return kebabCase(str || \"\", \"_\");\n}\nfunction flatCase(str) {\n  return kebabCase(str || \"\", \"\");\n}\nfunction trainCase(str, opts) {\n  return (Array.isArray(str) ? str : splitByCase(str)).filter(Boolean).map((p) => upperFirst(opts?.normalize ? p.toLowerCase() : p)).join(\"-\");\n}\nconst titleCaseExceptions = /^(a|an|and|as|at|but|by|for|if|in|is|nor|of|on|or|the|to|with)$/i;\nfunction titleCase(str, opts) {\n  return (Array.isArray(str) ? str : splitByCase(str)).filter(Boolean).map(\n    (p) => titleCaseExceptions.test(p) ? p.toLowerCase() : upperFirst(opts?.normalize ? p.toLowerCase() : p)\n  ).join(\" \");\n}\n\nexport { camelCase, flatCase, isUppercase, kebabCase, lowerFirst, pascalCase, snakeCase, splitByCase, titleCase, trainCase, upperFirst };\n","import destr from \"destr\";\nimport { snakeCase } from \"scule\";\nexport function getEnv(key, opts) {\n  const envKey = snakeCase(key).toUpperCase();\n  return destr(\n    process.env[opts.prefix + envKey] ?? process.env[opts.altPrefix + envKey]\n  );\n}\nfunction _isObject(input) {\n  return typeof input === \"object\" && !Array.isArray(input);\n}\nexport function applyEnv(obj, opts, parentKey = \"\") {\n  for (const key in obj) {\n    const subKey = parentKey ? `${parentKey}_${key}` : key;\n    const envValue = getEnv(subKey, opts);\n    if (_isObject(obj[key])) {\n      if (_isObject(envValue)) {\n        obj[key] = { ...obj[key], ...envValue };\n        applyEnv(obj[key], opts, subKey);\n      } else if (envValue === void 0) {\n        applyEnv(obj[key], opts, subKey);\n      } else {\n        obj[key] = envValue ?? obj[key];\n      }\n    } else {\n      obj[key] = envValue ?? obj[key];\n    }\n    if (opts.envExpansion && typeof obj[key] === \"string\") {\n      obj[key] = _expandFromEnv(obj[key]);\n    }\n  }\n  return obj;\n}\nconst envExpandRx = /{{(.*?)}}/g;\nfunction _expandFromEnv(value) {\n  return value.replace(envExpandRx, (match, key) => {\n    return process.env[key] || match;\n  });\n}\n","import { klona } from \"klona\";\nimport { appConfig as _inlineAppConfig } from \"#nitro-internal-virtual/app-config\";\nimport { applyEnv } from \"./utils.env.mjs\";\nconst _inlineRuntimeConfig = process.env.RUNTIME_CONFIG;\nconst envOptions = {\n  prefix: \"NITRO_\",\n  altPrefix: _inlineRuntimeConfig.nitro.envPrefix ?? process.env.NITRO_ENV_PREFIX ?? \"_\",\n  envExpansion: _inlineRuntimeConfig.nitro.envExpansion ?? process.env.NITRO_ENV_EXPANSION ?? false\n};\nconst _sharedRuntimeConfig = _deepFreeze(\n  applyEnv(klona(_inlineRuntimeConfig), envOptions)\n);\nexport function useRuntimeConfig(event) {\n  if (!event) {\n    return _sharedRuntimeConfig;\n  }\n  if (event.context.nitro.runtimeConfig) {\n    return event.context.nitro.runtimeConfig;\n  }\n  const runtimeConfig = klona(_inlineRuntimeConfig);\n  applyEnv(runtimeConfig, envOptions);\n  event.context.nitro.runtimeConfig = runtimeConfig;\n  return runtimeConfig;\n}\nconst _sharedAppConfig = _deepFreeze(klona(_inlineAppConfig));\nexport function useAppConfig(event) {\n  if (!event) {\n    return _sharedAppConfig;\n  }\n  if (event.context.nitro.appConfig) {\n    return event.context.nitro.appConfig;\n  }\n  const appConfig = klona(_inlineAppConfig);\n  event.context.nitro.appConfig = appConfig;\n  return appConfig;\n}\nfunction _deepFreeze(object) {\n  const propNames = Object.getOwnPropertyNames(object);\n  for (const name of propNames) {\n    const value = object[name];\n    if (value && typeof value === \"object\") {\n      _deepFreeze(value);\n    }\n  }\n  return Object.freeze(object);\n}\nexport default new Proxy(/* @__PURE__ */ Object.create(null), {\n  get: (_, prop) => {\n    console.warn(\n      \"Please use `useRuntimeConfig()` instead of accessing config directly.\"\n    );\n    const runtimeConfig = useRuntimeConfig();\n    if (prop in runtimeConfig) {\n      return runtimeConfig[prop];\n    }\n    return void 0;\n  }\n});\n","function wrapToPromise(value) {\n  if (!value || typeof value.then !== \"function\") {\n    return Promise.resolve(value);\n  }\n  return value;\n}\nfunction asyncCall(function_, ...arguments_) {\n  try {\n    return wrapToPromise(function_(...arguments_));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\nfunction isPrimitive(value) {\n  const type = typeof value;\n  return value === null || type !== \"object\" && type !== \"function\";\n}\nfunction isPureObject(value) {\n  const proto = Object.getPrototypeOf(value);\n  return !proto || proto.isPrototypeOf(Object);\n}\nfunction stringify(value) {\n  if (isPrimitive(value)) {\n    return String(value);\n  }\n  if (isPureObject(value) || Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (typeof value.toJSON === \"function\") {\n    return stringify(value.toJSON());\n  }\n  throw new Error(\"[unstorage] Cannot stringify value!\");\n}\nfunction checkBufferSupport() {\n  if (typeof Buffer === \"undefined\") {\n    throw new TypeError(\"[unstorage] Buffer is not supported!\");\n  }\n}\nconst BASE64_PREFIX = \"base64:\";\nfunction serializeRaw(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  checkBufferSupport();\n  const base64 = Buffer.from(value).toString(\"base64\");\n  return BASE64_PREFIX + base64;\n}\nfunction deserializeRaw(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (!value.startsWith(BASE64_PREFIX)) {\n    return value;\n  }\n  checkBufferSupport();\n  return Buffer.from(value.slice(BASE64_PREFIX.length), \"base64\");\n}\n\nconst storageKeyProperties = [\n  \"hasItem\",\n  \"getItem\",\n  \"getItemRaw\",\n  \"setItem\",\n  \"setItemRaw\",\n  \"removeItem\",\n  \"getMeta\",\n  \"setMeta\",\n  \"removeMeta\",\n  \"getKeys\",\n  \"clear\",\n  \"mount\",\n  \"unmount\"\n];\nfunction prefixStorage(storage, base) {\n  base = normalizeBaseKey(base);\n  if (!base) {\n    return storage;\n  }\n  const nsStorage = { ...storage };\n  for (const property of storageKeyProperties) {\n    nsStorage[property] = (key = \"\", ...args) => (\n      // @ts-ignore\n      storage[property](base + key, ...args)\n    );\n  }\n  nsStorage.getKeys = (key = \"\", ...arguments_) => storage.getKeys(base + key, ...arguments_).then((keys) => keys.map((key2) => key2.slice(base.length)));\n  return nsStorage;\n}\nfunction normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.split(\"?\")[0].replace(/[/\\\\]/g, \":\").replace(/:+/g, \":\").replace(/^:|:$/g, \"\");\n}\nfunction joinKeys(...keys) {\n  return normalizeKey(keys.join(\":\"));\n}\nfunction normalizeBaseKey(base) {\n  base = normalizeKey(base);\n  return base ? base + \":\" : \"\";\n}\n\nexport { normalizeKey as a, asyncCall as b, serializeRaw as c, deserializeRaw as d, joinKeys as j, normalizeBaseKey as n, prefixStorage as p, stringify as s };\n","import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, d as deserializeRaw, s as stringify, c as serializeRaw, j as joinKeys } from './shared/unstorage.d569726e.mjs';\nexport { p as prefixStorage } from './shared/unstorage.d569726e.mjs';\n\nfunction defineDriver(factory) {\n  return factory;\n}\n\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */ new Map();\n  return {\n    name: DRIVER_NAME,\n    getInstance: () => data,\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return [...data.keys()];\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\n\nfunction createStorage(options = {}) {\n  const context = {\n    mounts: { \"\": options.driver || memory() },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = (key) => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(\n      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)\n    ).map((mountpoint) => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(\n        context.mounts[mountpoint],\n        onChange,\n        mountpoint\n      );\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */ new Map();\n    const getBatch = (mount) => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(\n      (r) => r.flat()\n    );\n  };\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => destr(value)\n      );\n    },\n    getItems(items, commonOptions) {\n      return runBatch(items, commonOptions, (batch) => {\n        if (batch.driver.getItems) {\n          return asyncCall(\n            batch.driver.getItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              options: item.options\n            })),\n            commonOptions\n          ).then(\n            (r) => r.map((item) => ({\n              key: joinKeys(batch.base, item.key),\n              value: destr(item.value)\n            }))\n          );\n        }\n        return Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.getItem,\n              item.relativeKey,\n              item.options\n            ).then((value) => ({\n              key: item.key,\n              value: destr(value)\n            }));\n          })\n        );\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => deserializeRaw(value)\n      );\n    },\n    async setItem(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async (batch) => {\n        if (batch.driver.setItems) {\n          return asyncCall(\n            batch.driver.setItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              value: stringify(item.value),\n              options: item.options\n            })),\n            commonOptions\n          );\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.setItem,\n              item.relativeKey,\n              stringify(item.value),\n              item.options\n            );\n          })\n        );\n      });\n    },\n    async setItemRaw(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { removeMeta: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { nativeOnly: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      const meta = /* @__PURE__ */ Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(\n          driver.getItem,\n          relativeKey + \"$\",\n          opts\n        ).then((value_) => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value, opts = {}) {\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      for (const mount of mounts) {\n        const rawKeys = await asyncCall(\n          mount.driver.getKeys,\n          mount.relativeBase,\n          opts\n        );\n        for (const key of rawKeys) {\n          const fullKey = mount.mountpoint + normalizeKey(key);\n          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {\n            allKeys.push(fullKey);\n          }\n        }\n        maskedMounts = [\n          mount.mountpoint,\n          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))\n        ];\n      }\n      return base ? allKeys.filter(\n        (key) => key.startsWith(base) && key[key.length - 1] !== \"$\"\n      ) : allKeys.filter((key) => key[key.length - 1] !== \"$\");\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(\n        getMounts(base, false).map(async (m) => {\n          if (m.driver.clear) {\n            return asyncCall(m.driver.clear, m.relativeBase, opts);\n          }\n          if (m.driver.removeItem) {\n            const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n            return Promise.all(\n              keys.map((key) => m.driver.removeItem(key, opts))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(context.mounts).map((driver) => dispose(driver))\n      );\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(\n          (listener) => listener !== callback\n        );\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter((key) => key !== base);\n      delete context.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map((m) => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    },\n    // Aliases\n    keys: (base, opts = {}) => storage.getKeys(base, opts),\n    get: (key, opts = {}) => storage.getItem(key, opts),\n    set: (key, value, opts = {}) => storage.setItem(key, value, opts),\n    has: (key, opts = {}) => storage.hasItem(key, opts),\n    del: (key, opts = {}) => storage.removeItem(key, opts),\n    remove: (key, opts = {}) => storage.removeItem(key, opts)\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(\n    keys.map(async (key) => {\n      snapshot2[key.slice(base.length)] = await storage.getItem(key);\n    })\n  );\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2, base = \"\") {\n  base = normalizeBaseKey(base);\n  await Promise.all(\n    Object.entries(snapshot2).map((e) => driver.setItem(base + e[0], e[1]))\n  );\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {\n  };\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\n\nconst builtinDrivers = {\n  azureAppConfiguration: \"unstorage/drivers/azure-app-configuration\",\n  azureCosmos: \"unstorage/drivers/azure-cosmos\",\n  azureKeyVault: \"unstorage/drivers/azure-key-vault\",\n  azureStorageBlob: \"unstorage/drivers/azure-storage-blob\",\n  azureStorageTable: \"unstorage/drivers/azure-storage-table\",\n  cloudflareKVBinding: \"unstorage/drivers/cloudflare-kv-binding\",\n  cloudflareKVHTTP: \"unstorage/drivers/cloudflare-kv-http\",\n  cloudflareR2Binding: \"unstorage/drivers/cloudflare-r2-binding\",\n  fs: \"unstorage/drivers/fs\",\n  fsLite: \"unstorage/drivers/fs-lite\",\n  github: \"unstorage/drivers/github\",\n  http: \"unstorage/drivers/http\",\n  indexedb: \"unstorage/drivers/indexedb\",\n  localStorage: \"unstorage/drivers/localstorage\",\n  lruCache: \"unstorage/drivers/lru-cache\",\n  memory: \"unstorage/drivers/memory\",\n  mongodb: \"unstorage/drivers/mongodb\",\n  netlifyBlobs: \"unstorage/drivers/netlify-blobs\",\n  null: \"unstorage/drivers/null\",\n  overlay: \"unstorage/drivers/overlay\",\n  planetscale: \"unstorage/drivers/planetscale\",\n  redis: \"unstorage/drivers/redis\",\n  sessionStorage: \"unstorage/drivers/session-storage\",\n  vercelKV: \"unstorage/drivers/vercel-kv\",\n  /** @deprecated */\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  /** @deprecated */\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\"\n};\n\nexport { builtinDrivers, createStorage, defineDriver, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };\n","export function defineDriver(factory) {\n  return factory;\n}\nexport function normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.replace(/[/\\\\]/g, \":\").replace(/^:|:$/g, \"\");\n}\nexport function joinKeys(...keys) {\n  return keys.map((key) => normalizeKey(key)).filter(Boolean).join(\":\");\n}\nexport function createError(driver, message, opts) {\n  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);\n  return err;\n}\nexport function createRequiredError(driver, name) {\n  if (Array.isArray(name)) {\n    return createError(\n      driver,\n      `Missing some of the required options ${name.map((n) => \"`\" + n + \"`\").join(\", \")}`\n    );\n  }\n  return createError(driver, `Missing required option \\`${name}\\`.`);\n}\n","import { existsSync, promises as fsPromises } from \"node:fs\";\nimport { resolve, dirname } from \"node:path\";\nfunction ignoreNotfound(err) {\n  return err.code === \"ENOENT\" || err.code === \"EISDIR\" ? null : err;\n}\nfunction ignoreExists(err) {\n  return err.code === \"EEXIST\" ? null : err;\n}\nexport async function writeFile(path, data, encoding) {\n  await ensuredir(dirname(path));\n  return fsPromises.writeFile(path, data, encoding);\n}\nexport function readFile(path, encoding) {\n  return fsPromises.readFile(path, encoding).catch(ignoreNotfound);\n}\nexport function stat(path) {\n  return fsPromises.stat(path).catch(ignoreNotfound);\n}\nexport function unlink(path) {\n  return fsPromises.unlink(path).catch(ignoreNotfound);\n}\nexport function readdir(dir) {\n  return fsPromises.readdir(dir, { withFileTypes: true }).catch(ignoreNotfound).then((r) => r || []);\n}\nexport async function ensuredir(dir) {\n  if (existsSync(dir)) {\n    return;\n  }\n  await ensuredir(dirname(dir)).catch(ignoreExists);\n  await fsPromises.mkdir(dir).catch(ignoreExists);\n}\nexport async function readdirRecursive(dir, ignore) {\n  if (ignore && ignore(dir)) {\n    return [];\n  }\n  const entries = await readdir(dir);\n  const files = [];\n  await Promise.all(\n    entries.map(async (entry) => {\n      const entryPath = resolve(dir, entry.name);\n      if (entry.isDirectory()) {\n        const dirFiles = await readdirRecursive(entryPath, ignore);\n        files.push(...dirFiles.map((f) => entry.name + \"/\" + f));\n      } else {\n        if (!(ignore && ignore(entry.name))) {\n          files.push(entry.name);\n        }\n      }\n    })\n  );\n  return files;\n}\nexport async function rmRecursive(dir) {\n  const entries = await readdir(dir);\n  await Promise.all(\n    entries.map((entry) => {\n      const entryPath = resolve(dir, entry.name);\n      if (entry.isDirectory()) {\n        return rmRecursive(entryPath).then(() => fsPromises.rmdir(entryPath));\n      } else {\n        return fsPromises.unlink(entryPath);\n      }\n    })\n  );\n}\n","import { existsSync, promises as fsp } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport { createError, createRequiredError, defineDriver } from \"./utils/index.mjs\";\nimport {\n  readFile,\n  writeFile,\n  readdirRecursive,\n  rmRecursive,\n  unlink\n} from \"./utils/node-fs.mjs\";\nconst PATH_TRAVERSE_RE = /\\.\\.:|\\.\\.$/;\nconst DRIVER_NAME = \"fs-lite\";\nexport default defineDriver((opts = {}) => {\n  if (!opts.base) {\n    throw createRequiredError(DRIVER_NAME, \"base\");\n  }\n  opts.base = resolve(opts.base);\n  const r = (key) => {\n    if (PATH_TRAVERSE_RE.test(key)) {\n      throw createError(\n        DRIVER_NAME,\n        `Invalid key: ${JSON.stringify(key)}. It should not contain .. segments`\n      );\n    }\n    const resolved = join(opts.base, key.replace(/:/g, \"/\"));\n    return resolved;\n  };\n  return {\n    name: DRIVER_NAME,\n    options: opts,\n    hasItem(key) {\n      return existsSync(r(key));\n    },\n    getItem(key) {\n      return readFile(r(key), \"utf8\");\n    },\n    getItemRaw(key) {\n      return readFile(r(key));\n    },\n    async getMeta(key) {\n      const { atime, mtime, size, birthtime, ctime } = await fsp.stat(r(key)).catch(() => ({}));\n      return { atime, mtime, size, birthtime, ctime };\n    },\n    setItem(key, value) {\n      if (opts.readOnly) {\n        return;\n      }\n      return writeFile(r(key), value, \"utf8\");\n    },\n    setItemRaw(key, value) {\n      if (opts.readOnly) {\n        return;\n      }\n      return writeFile(r(key), value);\n    },\n    removeItem(key) {\n      if (opts.readOnly) {\n        return;\n      }\n      return unlink(r(key));\n    },\n    getKeys() {\n      return readdirRecursive(r(\".\"), opts.ignore);\n    },\n    async clear() {\n      if (opts.readOnly || opts.noClear) {\n        return;\n      }\n      await rmRecursive(r(\".\"));\n    }\n  };\n});\n","import { defineDriver } from \"./utils/index.mjs\";\nimport { normalizeKey } from \"./utils/index.mjs\";\nconst OVERLAY_REMOVED = \"__OVERLAY_REMOVED__\";\nconst DRIVER_NAME = \"overlay\";\nexport default defineDriver((options) => {\n  return {\n    name: DRIVER_NAME,\n    options,\n    async hasItem(key, opts) {\n      for (const layer of options.layers) {\n        if (await layer.hasItem(key, opts)) {\n          if (layer === options.layers[0] && await options.layers[0]?.getItem(key) === OVERLAY_REMOVED) {\n            return false;\n          }\n          return true;\n        }\n      }\n      return false;\n    },\n    async getItem(key) {\n      for (const layer of options.layers) {\n        const value = await layer.getItem(key);\n        if (value === OVERLAY_REMOVED) {\n          return null;\n        }\n        if (value !== null) {\n          return value;\n        }\n      }\n      return null;\n    },\n    // TODO: Support native meta\n    // async getMeta (key) {},\n    async setItem(key, value, opts) {\n      await options.layers[0]?.setItem?.(key, value, opts);\n    },\n    async removeItem(key, opts) {\n      await options.layers[0]?.setItem?.(key, OVERLAY_REMOVED, opts);\n    },\n    async getKeys(base, opts) {\n      const allKeys = await Promise.all(\n        options.layers.map(async (layer) => {\n          const keys = await layer.getKeys(base, opts);\n          return keys.map((key) => normalizeKey(key));\n        })\n      );\n      const uniqueKeys = [...new Set(allKeys.flat())];\n      const existingKeys = await Promise.all(\n        uniqueKeys.map(async (key) => {\n          if (await options.layers[0]?.getItem(key) === OVERLAY_REMOVED) {\n            return false;\n          }\n          return key;\n        })\n      );\n      return existingKeys.filter(Boolean);\n    },\n    async dispose() {\n      await Promise.all(\n        options.layers.map(async (layer) => {\n          if (layer.dispose) {\n            await layer.dispose();\n          }\n        })\n      );\n    }\n  };\n});\n","import { defineDriver } from \"./utils/index.mjs\";\nconst DRIVER_NAME = \"memory\";\nexport default defineDriver(() => {\n  const data = /* @__PURE__ */ new Map();\n  return {\n    name: DRIVER_NAME,\n    getInstance: () => data,\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return [...data.keys()];\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\n","import { prefixStorage } from \"unstorage\";\nimport { storage } from \"#nitro-internal-virtual/storage\";\nexport function useStorage(base = \"\") {\n  return base ? prefixStorage(storage, base) : storage;\n}\n","import {\n  createEvent,\n  defineEventHandler,\n  fetchWithEvent,\n  handleCacheHeaders,\n  isEvent,\n  splitCookiesString\n} from \"h3\";\nimport { hash } from \"ohash\";\nimport { parseURL } from \"ufo\";\nimport { useNitroApp } from \"./app.mjs\";\nimport { useStorage } from \"./storage.mjs\";\nfunction defaultCacheOptions() {\n  return {\n    name: \"_\",\n    base: \"/cache\",\n    swr: true,\n    maxAge: 1\n  };\n}\nexport function defineCachedFunction(fn, opts = {}) {\n  opts = { ...defaultCacheOptions(), ...opts };\n  const pending = {};\n  const group = opts.group || \"nitro/functions\";\n  const name = opts.name || fn.name || \"_\";\n  const integrity = opts.integrity || hash([fn, opts]);\n  const validate = opts.validate || ((entry) => entry.value !== void 0);\n  async function get(key, resolver, shouldInvalidateCache, event) {\n    const cacheKey = [opts.base, group, name, key + \".json\"].filter(Boolean).join(\":\").replace(/:\\/$/, \":index\");\n    let entry = await useStorage().getItem(cacheKey).catch((error) => {\n      console.error(`[nitro] [cache] Cache read error.`, error);\n      useNitroApp().captureError(error, { event, tags: [\"cache\"] });\n    }) || {};\n    if (typeof entry !== \"object\") {\n      entry = {};\n      const error = new Error(\"Malformed data read from cache.\");\n      console.error(\"[nitro] [cache]\", error);\n      useNitroApp().captureError(error, { event, tags: [\"cache\"] });\n    }\n    const ttl = (opts.maxAge ?? 0) * 1e3;\n    if (ttl) {\n      entry.expires = Date.now() + ttl;\n    }\n    const expired = shouldInvalidateCache || entry.integrity !== integrity || ttl && Date.now() - (entry.mtime || 0) > ttl || validate(entry) === false;\n    const _resolve = async () => {\n      const isPending = pending[key];\n      if (!isPending) {\n        if (entry.value !== void 0 && (opts.staleMaxAge || 0) >= 0 && opts.swr === false) {\n          entry.value = void 0;\n          entry.integrity = void 0;\n          entry.mtime = void 0;\n          entry.expires = void 0;\n        }\n        pending[key] = Promise.resolve(resolver());\n      }\n      try {\n        entry.value = await pending[key];\n      } catch (error) {\n        if (!isPending) {\n          delete pending[key];\n        }\n        throw error;\n      }\n      if (!isPending) {\n        entry.mtime = Date.now();\n        entry.integrity = integrity;\n        delete pending[key];\n        if (validate(entry) !== false) {\n          let setOpts;\n          if (opts.maxAge && !opts.swr) {\n            setOpts = { ttl: opts.maxAge };\n          }\n          const promise = useStorage().setItem(cacheKey, entry, setOpts).catch((error) => {\n            console.error(`[nitro] [cache] Cache write error.`, error);\n            useNitroApp().captureError(error, { event, tags: [\"cache\"] });\n          });\n          if (event?.waitUntil) {\n            event.waitUntil(promise);\n          }\n        }\n      }\n    };\n    const _resolvePromise = expired ? _resolve() : Promise.resolve();\n    if (entry.value === void 0) {\n      await _resolvePromise;\n    } else if (expired && event && event.waitUntil) {\n      event.waitUntil(_resolvePromise);\n    }\n    if (opts.swr && validate(entry) !== false) {\n      _resolvePromise.catch((error) => {\n        console.error(`[nitro] [cache] SWR handler error.`, error);\n        useNitroApp().captureError(error, { event, tags: [\"cache\"] });\n      });\n      return entry;\n    }\n    return _resolvePromise.then(() => entry);\n  }\n  return async (...args) => {\n    const shouldBypassCache = await opts.shouldBypassCache?.(...args);\n    if (shouldBypassCache) {\n      return fn(...args);\n    }\n    const key = await (opts.getKey || getKey)(...args);\n    const shouldInvalidateCache = await opts.shouldInvalidateCache?.(...args);\n    const entry = await get(\n      key,\n      () => fn(...args),\n      shouldInvalidateCache,\n      args[0] && isEvent(args[0]) ? args[0] : void 0\n    );\n    let value = entry.value;\n    if (opts.transform) {\n      value = await opts.transform(entry, ...args) || value;\n    }\n    return value;\n  };\n}\nexport function cachedFunction(fn, opts = {}) {\n  return defineCachedFunction(fn, opts);\n}\nfunction getKey(...args) {\n  return args.length > 0 ? hash(args, {}) : \"\";\n}\nfunction escapeKey(key) {\n  return String(key).replace(/\\W/g, \"\");\n}\nexport function defineCachedEventHandler(handler, opts = defaultCacheOptions()) {\n  const variableHeaderNames = (opts.varies || []).filter(Boolean).map((h) => h.toLowerCase()).sort();\n  const _opts = {\n    ...opts,\n    getKey: async (event) => {\n      const customKey = await opts.getKey?.(event);\n      if (customKey) {\n        return escapeKey(customKey);\n      }\n      const _path = event.node.req.originalUrl || event.node.req.url || event.path;\n      let _pathname;\n      try {\n        _pathname = escapeKey(decodeURI(parseURL(_path).pathname)).slice(0, 16) || \"index\";\n      } catch {\n        _pathname = \"-\";\n      }\n      const _hashedPath = `${_pathname}.${hash(_path)}`;\n      const _headers = variableHeaderNames.map((header) => [header, event.node.req.headers[header]]).map(([name, value]) => `${escapeKey(name)}.${hash(value)}`);\n      return [_hashedPath, ..._headers].join(\":\");\n    },\n    validate: (entry) => {\n      if (!entry.value) {\n        return false;\n      }\n      if (entry.value.code >= 400) {\n        return false;\n      }\n      if (entry.value.body === void 0) {\n        return false;\n      }\n      if (entry.value.headers.etag === \"undefined\" || entry.value.headers[\"last-modified\"] === \"undefined\") {\n        return false;\n      }\n      return true;\n    },\n    group: opts.group || \"nitro/handlers\",\n    integrity: opts.integrity || hash([handler, opts])\n  };\n  const _cachedHandler = cachedFunction(\n    async (incomingEvent) => {\n      const variableHeaders = {};\n      for (const header of variableHeaderNames) {\n        const value = incomingEvent.node.req.headers[header];\n        if (value !== void 0) {\n          variableHeaders[header] = value;\n        }\n      }\n      const reqProxy = cloneWithProxy(incomingEvent.node.req, {\n        headers: variableHeaders\n      });\n      const resHeaders = {};\n      let _resSendBody;\n      const resProxy = cloneWithProxy(incomingEvent.node.res, {\n        statusCode: 200,\n        writableEnded: false,\n        writableFinished: false,\n        headersSent: false,\n        closed: false,\n        getHeader(name) {\n          return resHeaders[name];\n        },\n        setHeader(name, value) {\n          resHeaders[name] = value;\n          return this;\n        },\n        getHeaderNames() {\n          return Object.keys(resHeaders);\n        },\n        hasHeader(name) {\n          return name in resHeaders;\n        },\n        removeHeader(name) {\n          delete resHeaders[name];\n        },\n        getHeaders() {\n          return resHeaders;\n        },\n        end(chunk, arg2, arg3) {\n          if (typeof chunk === \"string\") {\n            _resSendBody = chunk;\n          }\n          if (typeof arg2 === \"function\") {\n            arg2();\n          }\n          if (typeof arg3 === \"function\") {\n            arg3();\n          }\n          return this;\n        },\n        write(chunk, arg2, arg3) {\n          if (typeof chunk === \"string\") {\n            _resSendBody = chunk;\n          }\n          if (typeof arg2 === \"function\") {\n            arg2(void 0);\n          }\n          if (typeof arg3 === \"function\") {\n            arg3();\n          }\n          return true;\n        },\n        writeHead(statusCode, headers2) {\n          this.statusCode = statusCode;\n          if (headers2) {\n            if (Array.isArray(headers2) || typeof headers2 === \"string\") {\n              throw new TypeError(\"Raw headers  is not supported.\");\n            }\n            for (const header in headers2) {\n              const value = headers2[header];\n              if (value !== void 0) {\n                this.setHeader(\n                  header,\n                  value\n                );\n              }\n            }\n          }\n          return this;\n        }\n      });\n      const event = createEvent(reqProxy, resProxy);\n      event.fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {\n        fetch: useNitroApp().localFetch\n      });\n      event.$fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {\n        fetch: globalThis.$fetch\n      });\n      event.context = incomingEvent.context;\n      event.context.cache = {\n        options: _opts\n      };\n      const body = await handler(event) || _resSendBody;\n      const headers = event.node.res.getHeaders();\n      headers.etag = String(\n        headers.Etag || headers.etag || `W/\"${hash(body)}\"`\n      );\n      headers[\"last-modified\"] = String(\n        headers[\"Last-Modified\"] || headers[\"last-modified\"] || (/* @__PURE__ */ new Date()).toUTCString()\n      );\n      const cacheControl = [];\n      if (opts.swr) {\n        if (opts.maxAge) {\n          cacheControl.push(`s-maxage=${opts.maxAge}`);\n        }\n        if (opts.staleMaxAge) {\n          cacheControl.push(`stale-while-revalidate=${opts.staleMaxAge}`);\n        } else {\n          cacheControl.push(\"stale-while-revalidate\");\n        }\n      } else if (opts.maxAge) {\n        cacheControl.push(`max-age=${opts.maxAge}`);\n      }\n      if (cacheControl.length > 0) {\n        headers[\"cache-control\"] = cacheControl.join(\", \");\n      }\n      const cacheEntry = {\n        code: event.node.res.statusCode,\n        headers,\n        body\n      };\n      return cacheEntry;\n    },\n    _opts\n  );\n  return defineEventHandler(async (event) => {\n    if (opts.headersOnly) {\n      if (handleCacheHeaders(event, { maxAge: opts.maxAge })) {\n        return;\n      }\n      return handler(event);\n    }\n    const response = await _cachedHandler(\n      event\n    );\n    if (event.node.res.headersSent || event.node.res.writableEnded) {\n      return response.body;\n    }\n    if (handleCacheHeaders(event, {\n      modifiedTime: new Date(response.headers[\"last-modified\"]),\n      etag: response.headers.etag,\n      maxAge: opts.maxAge\n    })) {\n      return;\n    }\n    event.node.res.statusCode = response.code;\n    for (const name in response.headers) {\n      const value = response.headers[name];\n      if (name === \"set-cookie\") {\n        event.node.res.appendHeader(\n          name,\n          splitCookiesString(value)\n        );\n      } else {\n        if (value !== void 0) {\n          event.node.res.setHeader(name, value);\n        }\n      }\n    }\n    return response.body;\n  });\n}\nfunction cloneWithProxy(obj, overrides) {\n  return new Proxy(obj, {\n    get(target, property, receiver) {\n      if (property in overrides) {\n        return overrides[property];\n      }\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      if (property in overrides) {\n        overrides[property] = value;\n        return true;\n      }\n      return Reflect.set(target, property, value, receiver);\n    }\n  });\n}\nexport const cachedEventHandler = defineCachedEventHandler;\n","import {\n  eventHandler,\n  getResponseStatus,\n  send,\n  setResponseHeader,\n  setResponseHeaders,\n  setResponseStatus\n} from \"h3\";\nimport { useNitroApp } from \"./app.mjs\";\nimport { useRuntimeConfig } from \"./config.mjs\";\nexport function defineRenderHandler(render) {\n  const runtimeConfig = useRuntimeConfig();\n  return eventHandler(async (event) => {\n    const nitroApp = useNitroApp();\n    const ctx = { event, render, response: void 0 };\n    await nitroApp.hooks.callHook(\"render:before\", ctx);\n    if (!ctx.response) {\n      if (event.path === `${runtimeConfig.app.baseURL}favicon.ico`) {\n        setResponseHeader(event, \"Content-Type\", \"image/x-icon\");\n        return send(\n          event,\n          \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n        );\n      }\n      ctx.response = await ctx.render(event);\n      if (!ctx.response) {\n        const _currentStatus = getResponseStatus(event);\n        setResponseStatus(event, _currentStatus === 200 ? 500 : _currentStatus);\n        return send(\n          event,\n          \"No response returned from render handler: \" + event.path\n        );\n      }\n    }\n    await nitroApp.hooks.callHook(\"render:response\", ctx.response, ctx);\n    if (ctx.response.headers) {\n      setResponseHeaders(event, ctx.response.headers);\n    }\n    if (ctx.response.statusCode || ctx.response.statusMessage) {\n      setResponseStatus(\n        event,\n        ctx.response.statusCode,\n        ctx.response.statusMessage\n      );\n    }\n    return ctx.response.body;\n  });\n}\n","import defu from \"defu\";\nimport {\n  eventHandler,\n  proxyRequest,\n  sendRedirect,\n  setHeaders\n} from \"h3\";\nimport { createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { getQuery, joinURL, withQuery, withoutBase } from \"ufo\";\nimport { useRuntimeConfig } from \"./config.mjs\";\nconst config = useRuntimeConfig();\nconst _routeRulesMatcher = toRouteMatcher(\n  createRadixRouter({ routes: config.nitro.routeRules })\n);\nexport function createRouteRulesHandler(ctx) {\n  return eventHandler((event) => {\n    const routeRules = getRouteRules(event);\n    if (routeRules.headers) {\n      setHeaders(event, routeRules.headers);\n    }\n    if (routeRules.redirect) {\n      let target = routeRules.redirect.to;\n      if (target.endsWith(\"/**\")) {\n        let targetPath = event.path;\n        const strpBase = routeRules.redirect._redirectStripBase;\n        if (strpBase) {\n          targetPath = withoutBase(targetPath, strpBase);\n        }\n        target = joinURL(target.slice(0, -3), targetPath);\n      } else if (event.path.includes(\"?\")) {\n        const query = getQuery(event.path);\n        target = withQuery(target, query);\n      }\n      return sendRedirect(event, target, routeRules.redirect.statusCode);\n    }\n    if (routeRules.proxy) {\n      let target = routeRules.proxy.to;\n      if (target.endsWith(\"/**\")) {\n        let targetPath = event.path;\n        const strpBase = routeRules.proxy._proxyStripBase;\n        if (strpBase) {\n          targetPath = withoutBase(targetPath, strpBase);\n        }\n        target = joinURL(target.slice(0, -3), targetPath);\n      } else if (event.path.includes(\"?\")) {\n        const query = getQuery(event.path);\n        target = withQuery(target, query);\n      }\n      return proxyRequest(event, target, {\n        fetch: ctx.localFetch,\n        ...routeRules.proxy\n      });\n    }\n  });\n}\nexport function getRouteRules(event) {\n  event.context._nitro = event.context._nitro || {};\n  if (!event.context._nitro.routeRules) {\n    event.context._nitro.routeRules = getRouteRulesForPath(\n      withoutBase(event.path.split(\"?\")[0], useRuntimeConfig().app.baseURL)\n    );\n  }\n  return event.context._nitro.routeRules;\n}\nexport function getRouteRulesForPath(path) {\n  return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());\n}\n","function createContext(opts = {}) {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  let als;\n  if (opts.asyncContext) {\n    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;\n    if (_AsyncLocalStorage) {\n      als = new _AsyncLocalStorage();\n    } else {\n      console.warn(\"[unctx] `AsyncLocalStorage` is not provided.\");\n    }\n  }\n  const _getCurrentInstance = () => {\n    if (als && currentInstance === void 0) {\n      const instance = als.getStore();\n      if (instance !== void 0) {\n        return instance;\n      }\n    }\n    return currentInstance;\n  };\n  return {\n    use: () => {\n      const _instance = _getCurrentInstance();\n      if (_instance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return _instance;\n    },\n    tryUse: () => {\n      return _getCurrentInstance();\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return als ? als.run(instance, callback) : callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = als ? als.run(instance, callback) : callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace(defaultOpts = {}) {\n  const contexts = {};\n  return {\n    get(key, opts = {}) {\n      if (!contexts[key]) {\n        contexts[key] = createContext({ ...defaultOpts, ...opts });\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key, opts = {}) => defaultNamespace.get(key, opts);\nconst useContext = (key, opts = {}) => getContext(key, opts).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\n      \"[unctx] `withAsyncContext` needs transformation for async context support in\",\n      function_,\n      \"\\n\",\n      function_.toString()\n    );\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { AsyncLocalStorage } from \"node:async_hooks\";\nimport { createError } from \"h3\";\nimport { getContext } from \"unctx\";\nexport const nitroAsyncContext = getContext(\"nitro-app\", {\n  asyncContext: import.meta._asyncContext,\n  AsyncLocalStorage: import.meta._asyncContext ? AsyncLocalStorage : void 0\n});\nexport function useEvent() {\n  try {\n    return nitroAsyncContext.use().event;\n  } catch {\n    const hint = import.meta._asyncContext ? \"Note: This is an experimental feature and might be broken on non-Node.js environments.\" : \"Enable the experimental flag using `experimental.asyncContext: true`.\";\n    throw createError({\n      message: `Nitro request context is not available. ${hint}`\n    });\n  }\n}\n","import { joinRelativeURL } from \"ufo\";\nimport { useRuntimeConfig } from \"#internal/nitro\";\nexport function baseURL() {\n  return useRuntimeConfig().app.baseURL;\n}\nexport function buildAssetsDir() {\n  return useRuntimeConfig().app.buildAssetsDir;\n}\nexport function buildAssetsURL(...path) {\n  return joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path);\n}\nexport function publicAssetsURL(...path) {\n  const app = useRuntimeConfig().app;\n  const publicBase = app.cdnURL || app.baseURL;\n  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase;\n}\n","export const TEXT_TAGS = [\"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"li\"];\nexport function isTag(vnode, tag) {\n  if (vnode.type === tag) {\n    return true;\n  }\n  if (typeof vnode.type === \"object\" && vnode.type.tag === tag) {\n    return true;\n  }\n  if (vnode.tag === tag) {\n    return true;\n  }\n  return false;\n}\nexport function isText(vnode) {\n  return isTag(vnode, \"text\") || isTag(vnode, Symbol.for(\"v-txt\"));\n}\nexport function nodeChildren(node) {\n  if (Array.isArray(node.children) || typeof node.children === \"string\") {\n    return node.children;\n  }\n  if (typeof node.children?.default === \"function\") {\n    return node.children.default();\n  }\n  return [];\n}\nexport function nodeTextContent(node) {\n  if (!node) {\n    return \"\";\n  }\n  if (Array.isArray(node)) {\n    return node.map(nodeTextContent).join(\"\");\n  }\n  if (isText(node)) {\n    return node.children || node.value || \"\";\n  }\n  const children = nodeChildren(node);\n  if (Array.isArray(children)) {\n    return children.map(nodeTextContent).filter(Boolean).join(\"\");\n  }\n  return \"\";\n}\nexport function unwrap(vnode, tags = []) {\n  if (Array.isArray(vnode)) {\n    return vnode.flatMap((node) => unwrap(node, tags));\n  }\n  let result = vnode;\n  if (tags.some((tag) => tag === \"*\" || isTag(vnode, tag))) {\n    result = nodeChildren(vnode) || vnode;\n    if (!Array.isArray(result) && TEXT_TAGS.some((tag) => isTag(vnode, tag))) {\n      result = [result];\n    }\n  }\n  return result;\n}\nfunction _flatUnwrap(vnodes, tags = []) {\n  vnodes = Array.isArray(vnodes) ? vnodes : [vnodes];\n  if (!tags.length) {\n    return vnodes;\n  }\n  return vnodes.flatMap((vnode) => _flatUnwrap(unwrap(vnode, [tags[0]]), tags.slice(1))).filter((vnode) => !(isText(vnode) && nodeTextContent(vnode).trim() === \"\"));\n}\nexport function flatUnwrap(vnodes, tags = []) {\n  if (typeof tags === \"string\") {\n    tags = tags.split(/[,\\s]/).map((tag) => tag.trim()).filter(Boolean);\n  }\n  if (!tags.length) {\n    return vnodes;\n  }\n  return _flatUnwrap(vnodes, tags).reduce((acc, item) => {\n    if (isText(item)) {\n      if (typeof acc[acc.length - 1] === \"string\") {\n        acc[acc.length - 1] += item.children;\n      } else {\n        acc.push(item.children);\n      }\n    } else {\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n","export const useProcessorPlugins = async (processor, plugins = {}) => {\n  const toUse = Object.entries(plugins).filter((p) => p[1] !== false);\n  for (const plugin of toUse) {\n    const instance = plugin[1].instance || await import(\n      /* @vite-ignore */\n      plugin[0]\n    ).then((m) => m.default || m);\n    processor.use(instance, plugin[1].options);\n  }\n};\n","export default function emphasis(state, node) {\n  const result = {\n    type: \"element\",\n    tagName: \"em\",\n    properties: node.attributes || {},\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export function parseThematicBlock(lang) {\n  if (!lang?.trim()) {\n    return {\n      language: void 0,\n      highlights: void 0,\n      filename: void 0,\n      meta: void 0\n    };\n  }\n  const languageMatches = lang.replace(/[{|[](.+)/, \"\").match(/^[^ \\t]+(?=[ \\t]|$)/);\n  const highlightTokensMatches = lang.match(/\\{([^}]*)\\}/);\n  const filenameMatches = lang.match(/\\[((\\\\\\]|[^\\]])*)\\]/);\n  const meta = lang.replace(languageMatches?.[0] ?? \"\", \"\").replace(highlightTokensMatches?.[0] ?? \"\", \"\").replace(filenameMatches?.[0] ?? \"\", \"\").trim();\n  return {\n    language: languageMatches?.[0] || void 0,\n    highlights: parseHighlightedLines(highlightTokensMatches?.[1] || void 0),\n    // https://github.com/nuxt/content/pull/2169\n    filename: filenameMatches?.[1].replace(/\\\\\\]/g, \"]\") || void 0,\n    meta\n  };\n}\nfunction parseHighlightedLines(lines) {\n  const lineArray = String(lines || \"\").split(\",\").filter(Boolean).flatMap((line) => {\n    const [start, end] = line.trim().split(\"-\").map((a) => Number(a.trim()));\n    return Array.from({ length: (end || start) - start + 1 }).map((_, i) => start + i);\n  });\n  return lineArray.length ? lineArray : void 0;\n}\nconst TAG_NAME_REGEXP = /^<\\/?([\\w-]+)(\\s[^>]*?)?\\/?>/;\nexport function getTagName(value) {\n  const result = String(value).match(TAG_NAME_REGEXP);\n  return result && result[1];\n}\n","import { detab } from \"detab\";\nimport { parseThematicBlock } from \"./utils.js\";\nexport default (state, node) => {\n  const lang = (node.lang || \"\") + \" \" + (node.meta || \"\");\n  const { language, highlights, filename, meta } = parseThematicBlock(lang);\n  const value = node.value ? detab(node.value + \"\\n\") : \"\";\n  let result = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: { __ignoreMap: \"\" },\n    children: [{ type: \"text\", value }]\n  };\n  if (meta) {\n    result.data = {\n      meta\n    };\n  }\n  state.patch(node, result);\n  result = state.applyData(node, result);\n  const properties = {\n    language,\n    filename,\n    highlights,\n    meta,\n    code: value\n  };\n  if (language) {\n    properties.className = [\"language-\" + language];\n  }\n  result = { type: \"element\", tagName: \"pre\", properties, children: [result] };\n  state.patch(node, result);\n  return result;\n};\n","import { kebabCase } from \"scule\";\nimport { getTagName } from \"./utils.js\";\nexport default function html(state, node) {\n  const tagName = getTagName(node.value);\n  if (tagName && /[A-Z]/.test(tagName)) {\n    node.value = node.value.replace(tagName, kebabCase(tagName));\n  }\n  if (state.dangerous || state.options?.allowDangerousHtml) {\n    const result = { type: \"raw\", value: node.value };\n    state.patch(node, result);\n    return state.applyData(node, result);\n  }\n  return void 0;\n}\n","import { normalizeUri } from \"micromark-util-sanitize-uri\";\nexport default function link(state, node) {\n  const properties = {\n    ...node.attributes || {},\n    href: normalizeUri(node.url)\n  };\n  if (node.title !== null && node.title !== void 0) {\n    properties.title = node.title;\n  }\n  const result = {\n    type: \"element\",\n    tagName: \"a\",\n    properties,\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export default function list(state, node) {\n  const properties = {};\n  const results = state.all(node);\n  let index = -1;\n  if (typeof node.start === \"number\" && node.start !== 1) {\n    properties.start = node.start;\n  }\n  while (++index < results.length) {\n    const child = results[index];\n    if (child.type === \"element\" && child.tagName === \"li\" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes(\"task-list-item\")) {\n      properties.className = [\"contains-task-list\"];\n      break;\n    }\n  }\n  if ((node.children || []).some((child) => typeof child.checked === \"boolean\")) {\n    properties.className = [\"contains-task-list\"];\n  }\n  const result = {\n    type: \"element\",\n    tagName: node.ordered ? \"ol\" : \"ul\",\n    properties,\n    children: state.wrap(results, true)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export default [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"math\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"slot\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"svg\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\"\n];\n","import { kebabCase } from \"scule\";\nimport htmlTags from \"../utils/html-tags-list.js\";\nimport { getTagName } from \"./utils.js\";\nexport default function paragraph(state, node) {\n  if (node.children && node.children[0] && node.children[0].type === \"html\") {\n    const tagName = kebabCase(getTagName(node.children[0].value) || \"div\");\n    if (!htmlTags.includes(tagName)) {\n      return state.all(node);\n    }\n  }\n  const result = {\n    type: \"element\",\n    tagName: \"p\",\n    properties: {},\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","import { normalizeUri } from \"micromark-util-sanitize-uri\";\nexport default function image(state, node) {\n  const properties = { ...node.attributes, src: normalizeUri(node.url) };\n  if (node.alt !== null && node.alt !== void 0) {\n    properties.alt = node.alt;\n  }\n  if (node.title !== null && node.title !== void 0) {\n    properties.title = node.title;\n  }\n  const result = { type: \"element\", tagName: \"img\", properties, children: [] };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export default function strong(state, node) {\n  const result = {\n    type: \"element\",\n    tagName: \"strong\",\n    properties: node.attributes || {},\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export default function inlineCode(state, node) {\n  const language = node.attributes?.language || node.attributes?.lang;\n  const text = { type: \"text\", value: node.value.replace(/\\r?\\n|\\r/g, \" \") };\n  state.patch(node, text);\n  const result = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: node.attributes || {},\n    children: [text]\n  };\n  const classes = (result.properties.class || \"\").split(\" \");\n  delete result.properties.class;\n  if (language) {\n    result.properties.language = language;\n    delete result.properties.lang;\n    classes.push(\"language-\" + language);\n  }\n  result.properties.className = classes.join(\" \");\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n","export default function containerComponent(state, node) {\n  const result = {\n    type: \"element\",\n    tagName: node.name,\n    properties: {\n      ...node.attributes,\n      ...node.data?.hProperties\n    },\n    children: state.all(node)\n  };\n  state.patch(node, result);\n  result.attributes = node.attributes;\n  result.fmAttributes = node.fmAttributes;\n  return result;\n}\n","import emphasis from \"./emphasis.js\";\nimport code from \"./code.js\";\nimport html from \"./html.js\";\nimport link from \"./link.js\";\nimport list from \"./list.js\";\nimport paragraph from \"./paragraph.js\";\nimport image from \"./image.js\";\nimport strong from \"./strong.js\";\nimport inlineCode from \"./inlineCode.js\";\nimport containerComponent from \"./containerComponent.js\";\nexport default {\n  emphasis,\n  code,\n  link,\n  paragraph,\n  html,\n  list,\n  image,\n  strong,\n  inlineCode,\n  containerComponent\n};\n","import remarkGFM from \"remark-gfm\";\nimport remarkMDC from \"remark-mdc\";\nimport rehypeExternalLinks from \"rehype-external-links\";\nimport rehypeSortAttributeValues from \"rehype-sort-attribute-values\";\nimport rehypeSortAttributes from \"rehype-sort-attributes\";\nimport rehypeRaw from \"rehype-raw\";\nimport handlers from \"./handlers/index.js\";\nexport const defaults = {\n  remark: {\n    plugins: {\n      \"remark-mdc\": {\n        instance: remarkMDC\n      },\n      \"remark-gfm\": {\n        instance: remarkGFM\n      }\n    }\n  },\n  rehype: {\n    options: {\n      handlers,\n      allowDangerousHtml: true\n    },\n    plugins: {\n      \"rehype-external-links\": {\n        instance: rehypeExternalLinks\n      },\n      \"rehype-sort-attribute-values\": {\n        instance: rehypeSortAttributeValues\n      },\n      \"rehype-sort-attributes\": {\n        instance: rehypeSortAttributes\n      },\n      \"rehype-raw\": {\n        instance: rehypeRaw,\n        options: {\n          passThrough: [\"element\"]\n        }\n      }\n    }\n  },\n  highlight: false,\n  toc: {\n    searchDepth: 2,\n    depth: 2\n  }\n};\n","export function flattenNodeText(node) {\n  if (node.type === \"comment\") {\n    return \"\";\n  }\n  if (node.type === \"text\") {\n    return node.value || \"\";\n  } else {\n    return (node.children || []).reduce((text, child) => {\n      return text.concat(flattenNodeText(child));\n    }, \"\");\n  }\n}\nexport function flattenNode(node, maxDepth = 2, _depth = 0) {\n  if (!Array.isArray(node.children) || _depth === maxDepth) {\n    return [node];\n  }\n  return [\n    node,\n    ...node.children.reduce((acc, child) => acc.concat(flattenNode(child, maxDepth, _depth + 1)), [])\n  ];\n}\nexport function setNodeData(node, name, value, pageData) {\n  if (!name.startsWith(\":\")) {\n    name = \":\" + name;\n  }\n  const dataKey = `content_d_${randomHash()}`;\n  pageData[dataKey] = value;\n  node.data.hProperties[name] = dataKey;\n}\nfunction randomHash() {\n  return Math.random().toString(36).substr(2, 16);\n}\n","import { flattenNode, flattenNodeText } from \"../utils/ast.js\";\nconst TOC_TAGS = [\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"];\nconst TOC_TAGS_DEPTH = TOC_TAGS.reduce((tags, tag) => {\n  tags[tag] = Number(tag.charAt(tag.length - 1));\n  return tags;\n}, {});\nconst getHeaderDepth = (node) => TOC_TAGS_DEPTH[node.tag];\nconst getTocTags = (depth) => {\n  if (depth < 1 || depth > 5) {\n    console.log(`\\`toc.depth\\` is set to ${depth}. It should be a number between 1 and 5. `);\n    depth = 1;\n  }\n  return TOC_TAGS.slice(0, depth);\n};\nfunction nestHeaders(headers) {\n  if (headers.length <= 1) {\n    return headers;\n  }\n  const toc = [];\n  let parent;\n  headers.forEach((header) => {\n    if (!parent || header.depth <= parent.depth) {\n      header.children = [];\n      parent = header;\n      toc.push(header);\n    } else {\n      parent.children.push(header);\n    }\n  });\n  toc.forEach((header) => {\n    if (header.children?.length) {\n      header.children = nestHeaders(header.children);\n    } else {\n      delete header.children;\n    }\n  });\n  return toc;\n}\nexport function generateFlatToc(body, options) {\n  const { searchDepth, depth, title = \"\" } = options;\n  const tags = getTocTags(depth);\n  const headers = flattenNode(body, searchDepth).filter((node) => tags.includes(node.tag || \"\"));\n  const links = headers.map((node) => ({\n    id: node.props?.id,\n    depth: getHeaderDepth(node),\n    text: flattenNodeText(node)\n  }));\n  return {\n    title,\n    searchDepth,\n    depth,\n    links\n  };\n}\nexport function generateToc(body, options) {\n  const toc = generateFlatToc(body, options);\n  toc.links = nestHeaders(toc.links);\n  return toc;\n}\n","export const unsafeLinkPrefix = [\n  \"javascript:\",\n  \"data:text/html\",\n  \"vbscript:\",\n  \"data:text/javascript\",\n  \"data:text/vbscript\",\n  \"data:text/css\",\n  \"data:text/plain\",\n  \"data:text/xml\"\n];\nexport const validateProp = (attribute, value) => {\n  if (attribute.startsWith(\"on\")) {\n    return false;\n  }\n  if (attribute === \"href\" || attribute === \"src\") {\n    return !unsafeLinkPrefix.some((prefix) => value.toLowerCase().startsWith(prefix));\n  }\n  return true;\n};\nexport const validateProps = (type, props) => {\n  if (!props) {\n    return {};\n  }\n  props = Object.fromEntries(\n    Object.entries(props).filter(([name, value]) => {\n      const isValid = validateProp(name, value);\n      if (!isValid) {\n        console.warn(`[@nuxtjs/mdc] removing unsafe attribute: ${name}=\"${value}\"`);\n      }\n      return isValid;\n    })\n  );\n  if (type === \"pre\") {\n    if (typeof props.highlights === \"string\") {\n      props.highlights = props.highlights.split(\" \").map((i) => Number.parseInt(i));\n    }\n  }\n  return props;\n};\n","import { toString } from \"hast-util-to-string\";\nimport Slugger from \"github-slugger\";\nimport { validateProps } from \"./utils/props.js\";\nexport function compileHast(options = {}) {\n  const slugs = new Slugger();\n  function compileToJSON(node, parent) {\n    if (node.type === \"root\") {\n      return {\n        type: \"root\",\n        children: node.children.map((child) => compileToJSON(child, node)).filter(Boolean)\n      };\n    }\n    if (node.type === \"element\") {\n      if (node.tagName === \"p\" && node.children.every((child) => child.type === \"text\" && /^\\s*$/.test(child.value))) {\n        return null;\n      }\n      if (node.tagName === \"li\") {\n        let hasPreviousParagraph = false;\n        node.children = node.children?.flatMap((child) => {\n          if (child.type === \"element\" && child.tagName === \"p\") {\n            if (hasPreviousParagraph) {\n              child.children.unshift({\n                type: \"element\",\n                tagName: \"br\",\n                properties: {},\n                children: []\n              });\n            }\n            hasPreviousParagraph = true;\n            return child.children;\n          }\n          return child;\n        });\n      }\n      if (node.tagName?.match(/^h\\d$/)) {\n        node.properties = node.properties || {};\n        node.properties.id = String(node.properties?.id || slugs.slug(toString(node))).replace(/-+/g, \"-\").replace(/^-|-$/g, \"\").replace(/^(\\d)/, \"_$1\");\n      }\n      if (node.tagName === \"component-slot\") {\n        node.tagName = \"template\";\n      }\n      const children = (node.tagName === \"template\" && node.content?.children.length ? node.content.children : node.children).map((child) => compileToJSON(child, node)).filter(Boolean);\n      return {\n        type: \"element\",\n        tag: node.tagName,\n        props: validateProps(node.tagName, node.properties),\n        children\n      };\n    }\n    if (node.type === \"text\") {\n      if (!/^\\n+$/.test(node.value || \"\") || parent?.properties?.emptyLinePlaceholder) {\n        return {\n          type: \"text\",\n          value: node.value\n        };\n      }\n    }\n    if (options.keepComments && node.type === \"comment\") {\n      return {\n        type: \"comment\",\n        value: node.value\n      };\n    }\n    return null;\n  }\n  this.Compiler = (tree) => {\n    const body = compileToJSON(tree);\n    let excerpt = void 0;\n    const excerptIndex = tree.children.findIndex((node) => node.type === \"comment\" && node.value?.trim() === \"more\");\n    if (excerptIndex !== -1) {\n      excerpt = compileToJSON({\n        type: \"root\",\n        children: tree.children.slice(0, excerptIndex)\n      });\n      if (excerpt.children.find((node) => node.type === \"element\" && node.tag === \"pre\")) {\n        const lastChild = body.children[body.children.length - 1];\n        if (lastChild.type === \"element\" && lastChild.tag === \"style\") {\n          excerpt.children.push(lastChild);\n        }\n      }\n    }\n    body.children = (body.children || []).filter((child) => child.type !== \"text\");\n    return {\n      body,\n      excerpt\n    };\n  };\n}\n","import { unified } from \"unified\";\nimport remarkParse from \"remark-parse\";\nimport remark2rehype from \"remark-rehype\";\nimport { parseFrontMatter } from \"remark-mdc\";\nimport { defu } from \"defu\";\nimport { nodeTextContent } from \"../utils/node.js\";\nimport { useProcessorPlugins } from \"./utils/plugins.js\";\nimport { defaults } from \"./options.js\";\nimport { generateToc } from \"./toc.js\";\nimport { compileHast } from \"./compiler.js\";\nlet moduleOptions;\nlet generatedMdcConfigs;\nexport const createMarkdownParser = async (inlineOptions = {}) => {\n  if (!moduleOptions) {\n    moduleOptions = await import(\n      \"#mdc-imports\"\n      /* @vite-ignore */\n    ).catch(() => ({}));\n  }\n  if (!generatedMdcConfigs) {\n    generatedMdcConfigs = await import(\n      \"#mdc-configs\"\n      /* @vite-ignore */\n    ).then((r) => r.getMdcConfigs()).catch(() => []);\n  }\n  const mdcConfigs = [\n    ...generatedMdcConfigs || [],\n    ...inlineOptions.configs || []\n  ];\n  if (inlineOptions.highlight != null && inlineOptions.highlight != false && inlineOptions.highlight.highlighter !== void 0 && typeof inlineOptions.highlight.highlighter !== \"function\") {\n    if (process.dev)\n      console.warn(\"[@nuxtjs/mdc] `highlighter` passed to `parseMarkdown` is should be a function, but got \" + JSON.stringify(inlineOptions.highlight.highlighter) + \", ignored.\");\n    inlineOptions = {\n      ...inlineOptions,\n      highlight: {\n        ...inlineOptions.highlight\n      }\n    };\n    delete inlineOptions.highlight.highlighter;\n  }\n  const options = defu(inlineOptions, {\n    remark: { plugins: moduleOptions?.remarkPlugins },\n    rehype: { plugins: moduleOptions?.rehypePlugins },\n    highlight: moduleOptions?.highlight\n  }, defaults);\n  if (options.rehype?.plugins?.highlight) {\n    options.rehype.plugins.highlight.options = {\n      ...options.rehype.plugins.highlight.options || {},\n      ...options.highlight || {}\n    };\n  }\n  let processor = unified();\n  for (const config of mdcConfigs) {\n    processor = await config.unified?.pre?.(processor) || processor;\n  }\n  processor.use(remarkParse);\n  for (const config of mdcConfigs) {\n    processor = await config.unified?.remark?.(processor) || processor;\n  }\n  await useProcessorPlugins(processor, options.remark?.plugins);\n  processor.use(remark2rehype, options.rehype?.options);\n  for (const config of mdcConfigs) {\n    processor = await config.unified?.rehype?.(processor) || processor;\n  }\n  await useProcessorPlugins(processor, options.rehype?.plugins);\n  processor.use(compileHast, options);\n  for (const config of mdcConfigs) {\n    processor = await config.unified?.post?.(processor) || processor;\n  }\n  return async function parse(md, { fileOptions } = {}) {\n    const { content, data: frontmatter } = await parseFrontMatter(md);\n    const processedFile = await processor.process({ ...fileOptions, value: content, data: frontmatter });\n    const result = processedFile.result;\n    const data = Object.assign(\n      contentHeading(result.body),\n      frontmatter,\n      processedFile?.data || {}\n    );\n    let toc;\n    if (data.toc !== false) {\n      const tocOption = defu(data.toc || {}, options.toc);\n      toc = generateToc(result.body, tocOption);\n    }\n    return {\n      data,\n      body: result.body,\n      excerpt: result.excerpt,\n      toc\n    };\n  };\n};\nexport const parseMarkdown = async (md, markdownParserOptions = {}, parseOptions = {}) => {\n  const parser = await createMarkdownParser(markdownParserOptions);\n  return parser(md, parseOptions);\n};\nexport function contentHeading(body) {\n  let title = \"\";\n  let description = \"\";\n  const children = body.children.filter((node) => node.type === \"element\" && node.tag !== \"hr\");\n  if (children.length && children[0].tag === \"h1\") {\n    const node = children.shift();\n    title = nodeTextContent(node);\n  }\n  if (children.length && children[0].tag === \"p\") {\n    const node = children.shift();\n    description = nodeTextContent(node);\n  }\n  return {\n    title,\n    description\n  };\n}\n","import { createError, defineEventHandler } from \"h3\";\nimport { useRuntimeConfig } from \"#imports\";\nexport default defineEventHandler(async (event) => {\n  const { getContentQuery } = await import(\"../../utils/query.js\");\n  const { serverQueryContent } = await import(\"../storage.js\");\n  const query = getContentQuery(event);\n  const { advanceQuery } = useRuntimeConfig().public.content.experimental;\n  if (query.first) {\n    let contentQuery = serverQueryContent(event, query);\n    if (!advanceQuery) {\n      contentQuery = contentQuery.withDirConfig();\n    }\n    const content = await contentQuery.findOne();\n    const _result = advanceQuery ? content?.result : content;\n    const missing = !_result && !content?.dirConfig?.navigation?.redirect && !content?._dir?.navigation?.redirect;\n    if (missing) {\n      throw createError({\n        statusMessage: \"Document not found!\",\n        statusCode: 404,\n        data: {\n          description: \"Could not find document for the given query.\",\n          query\n        }\n      });\n    }\n    return content;\n  }\n  if (query.count) {\n    return serverQueryContent(event, query).count();\n  }\n  return serverQueryContent(event, query).find();\n});\n","import { defineEventHandler } from \"h3\";\nimport { useRuntimeConfig } from \"#imports\";\nexport default defineEventHandler(async (event) => {\n  const { getContentIndex } = await import(\"../content-index.js\");\n  const { cacheStorage, serverQueryContent } = await import(\"../storage.js\");\n  const { content } = useRuntimeConfig();\n  const now = Date.now();\n  const contents = await serverQueryContent(event).find();\n  await getContentIndex(event);\n  const navigation = await $fetch(`${content.api.baseURL}/navigation`);\n  await cacheStorage().setItem(\"content-navigation.json\", navigation);\n  return {\n    generatedAt: now,\n    generateTime: Date.now() - now,\n    contents: content.experimental.cacheContents ? contents : [],\n    navigation\n  };\n});\n","import { getQuery, getCookie } from \"h3\";\nexport const isPreview = (event) => {\n  const previewToken = getQuery(event).previewToken || getCookie(event, \"previewToken\");\n  return !!previewToken;\n};\nexport const getPreview = (event) => {\n  const key = getQuery(event).previewToken || getCookie(event, \"previewToken\");\n  return { key };\n};\n","import { defineEventHandler } from \"h3\";\nimport { isPreview } from \"../preview.js\";\nexport default defineEventHandler(async (event) => {\n  const { getContentQuery } = await import(\"../../utils/query.js\");\n  const { cacheStorage, serverQueryContent } = await import(\"../storage.js\");\n  const { createNav } = await import(\"../navigation.js\");\n  const query = getContentQuery(event);\n  if (!isPreview(event) && Object.keys(query).length === 0) {\n    const cache = await cacheStorage().getItem(\"content-navigation.json\");\n    if (cache) {\n      return cache;\n    }\n  }\n  const contents = await serverQueryContent(event, query).where({\n    /**\n     * Partial contents are not included in the navigation\n     * A partial content is a content that has `_` prefix in its path\n     */\n    _partial: false,\n    /**\n     * Exclude any pages which have opted out of navigation via frontmatter.\n     */\n    navigation: {\n      $ne: false\n    }\n  }).find();\n  const _locale = (query?.where || []).find((w) => w._locale)?._locale;\n  const dirConfigs = await serverQueryContent(event, _locale ? { where: [{ _locale }] } : void 0).where({ _path: /\\/_dir$/i, _partial: true }).find();\n  const configs = (dirConfigs?.result || dirConfigs).reduce((configs2, conf) => {\n    if (conf.title?.toLowerCase() === \"dir\") {\n      conf.title = void 0;\n    }\n    const key = conf._path.split(\"/\").slice(0, -1).join(\"/\") || \"/\";\n    configs2[key] = {\n      ...conf,\n      // Extract meta from body. (non MD files)\n      ...conf.body\n    };\n    return configs2;\n  }, {});\n  return createNav(contents?.result || contents, configs);\n});\n","import destr from \"destr\";\nimport {\n  createApp,\n  createRouter,\n  eventHandler,\n  fetchWithEvent,\n  isEvent,\n  lazyEventHandler,\n  toNodeListener\n} from \"h3\";\nimport { createHooks } from \"hookable\";\nimport { Headers, createFetch } from \"ofetch\";\nimport {\n  createCall,\n  createFetch as createLocalFetch\n} from \"unenv/runtime/fetch/index\";\nimport errorHandler from \"#nitro-internal-virtual/error-handler\";\nimport { plugins } from \"#nitro-internal-virtual/plugins\";\nimport { handlers } from \"#nitro-internal-virtual/server-handlers\";\nimport { cachedEventHandler } from \"./cache.mjs\";\nimport { useRuntimeConfig } from \"./config.mjs\";\nimport { nitroAsyncContext } from \"./context.mjs\";\nimport { createRouteRulesHandler, getRouteRulesForPath } from \"./route-rules.mjs\";\nimport { normalizeFetchResponse } from \"./utils.mjs\";\nfunction createNitroApp() {\n  const config = useRuntimeConfig();\n  const hooks = createHooks();\n  const captureError = (error, context = {}) => {\n    const promise = hooks.callHookParallel(\"error\", error, context).catch((error_) => {\n      console.error(\"Error while capturing another error\", error_);\n    });\n    if (context.event && isEvent(context.event)) {\n      const errors = context.event.context.nitro?.errors;\n      if (errors) {\n        errors.push({ error, context });\n      }\n      if (context.event.waitUntil) {\n        context.event.waitUntil(promise);\n      }\n    }\n  };\n  const h3App = createApp({\n    debug: destr(process.env.DEBUG),\n    onError: (error, event) => {\n      captureError(error, { event, tags: [\"request\"] });\n      return errorHandler(error, event);\n    },\n    onRequest: async (event) => {\n      await nitroApp.hooks.callHook(\"request\", event).catch((error) => {\n        captureError(error, { event, tags: [\"request\"] });\n      });\n    },\n    onBeforeResponse: async (event, response) => {\n      await nitroApp.hooks.callHook(\"beforeResponse\", event, response).catch((error) => {\n        captureError(error, { event, tags: [\"request\", \"response\"] });\n      });\n    },\n    onAfterResponse: async (event, response) => {\n      await nitroApp.hooks.callHook(\"afterResponse\", event, response).catch((error) => {\n        captureError(error, { event, tags: [\"request\", \"response\"] });\n      });\n    }\n  });\n  const router = createRouter({\n    preemptive: true\n  });\n  const localCall = createCall(toNodeListener(h3App));\n  const _localFetch = createLocalFetch(localCall, globalThis.fetch);\n  const localFetch = (input, init) => _localFetch(input, init).then(\n    (response) => normalizeFetchResponse(response)\n  );\n  const $fetch = createFetch({\n    fetch: localFetch,\n    Headers,\n    defaults: { baseURL: config.app.baseURL }\n  });\n  globalThis.$fetch = $fetch;\n  h3App.use(createRouteRulesHandler({ localFetch }));\n  h3App.use(\n    eventHandler((event) => {\n      event.context.nitro = event.context.nitro || { errors: [] };\n      const envContext = event.node.req?.__unenv__;\n      if (envContext) {\n        Object.assign(event.context, envContext);\n      }\n      event.fetch = (req, init) => fetchWithEvent(event, req, init, { fetch: localFetch });\n      event.$fetch = (req, init) => fetchWithEvent(event, req, init, {\n        fetch: $fetch\n      });\n      event.waitUntil = (promise) => {\n        if (!event.context.nitro._waitUntilPromises) {\n          event.context.nitro._waitUntilPromises = [];\n        }\n        event.context.nitro._waitUntilPromises.push(promise);\n        if (envContext?.waitUntil) {\n          envContext.waitUntil(promise);\n        }\n      };\n      event.captureError = (error, context) => {\n        captureError(error, { event, ...context });\n      };\n    })\n  );\n  for (const h of handlers) {\n    let handler = h.lazy ? lazyEventHandler(h.handler) : h.handler;\n    if (h.middleware || !h.route) {\n      const middlewareBase = (config.app.baseURL + (h.route || \"/\")).replace(\n        /\\/+/g,\n        \"/\"\n      );\n      h3App.use(middlewareBase, handler);\n    } else {\n      const routeRules = getRouteRulesForPath(\n        h.route.replace(/:\\w+|\\*\\*/g, \"_\")\n      );\n      if (routeRules.cache) {\n        handler = cachedEventHandler(handler, {\n          group: \"nitro/routes\",\n          ...routeRules.cache\n        });\n      }\n      router.use(h.route, handler, h.method);\n    }\n  }\n  h3App.use(config.app.baseURL, router.handler);\n  if (import.meta._asyncContext) {\n    const _handler = h3App.handler;\n    h3App.handler = (event) => {\n      const ctx = { event };\n      return nitroAsyncContext.callAsync(ctx, () => _handler(event));\n    };\n  }\n  const app = {\n    hooks,\n    h3App,\n    router,\n    localCall,\n    localFetch,\n    captureError\n  };\n  return app;\n}\nfunction runNitroPlugins(nitroApp2) {\n  for (const plugin of plugins) {\n    try {\n      plugin(nitroApp2);\n    } catch (error) {\n      nitroApp2.captureError(error, { tags: [\"plugin\"] });\n      throw error;\n    }\n  }\n}\nexport const nitroApp = createNitroApp();\nexport function useNitroApp() {\n  return nitroApp;\n}\nrunNitroPlugins(nitroApp);\n","import { toBuffer } from \"./utils.mjs\";\nexport function normalizeLambdaIncomingHeaders(headers) {\n  return Object.fromEntries(\n    Object.entries(headers || {}).map(([key, value]) => [\n      key.toLowerCase(),\n      value\n    ])\n  );\n}\nexport function normalizeLambdaOutgoingHeaders(headers, stripCookies = false) {\n  const entries = stripCookies ? Object.entries(headers).filter(([key]) => ![\"set-cookie\"].includes(key)) : Object.entries(headers);\n  return Object.fromEntries(\n    entries.map(([k, v]) => [k, Array.isArray(v) ? v.join(\",\") : String(v)])\n  );\n}\nexport async function normalizeLambdaOutgoingBody(body, headers) {\n  if (typeof body === \"string\") {\n    return { type: \"text\", body };\n  }\n  if (!body) {\n    return { type: \"text\", body: \"\" };\n  }\n  const buffer = await toBuffer(body);\n  const contentType = headers[\"content-type\"] || \"\";\n  return isTextType(contentType) ? { type: \"text\", body: buffer.toString(\"utf8\") } : { type: \"binary\", body: buffer.toString(\"base64\") };\n}\nconst TEXT_TYPE_RE = /^text\\/|\\/(javascript|json|xml)|utf-?8/;\nfunction isTextType(contentType = \"\") {\n  return TEXT_TYPE_RE.test(contentType);\n}\n","import { parse } from \"cookie-es\";\nimport { splitCookiesString } from \"h3\";\nexport function getAzureParsedCookiesFromHeaders(headers) {\n  const setCookieHeader = headers[\"set-cookie\"];\n  if (!setCookieHeader || typeof setCookieHeader === \"number\" || setCookieHeader.length === 0) {\n    return [];\n  }\n  const azureCookies = [];\n  for (const setCookieStr of splitCookiesString(setCookieHeader)) {\n    const setCookie = Object.entries(parse(setCookieStr));\n    if (setCookie.length === 0) {\n      continue;\n    }\n    const [[key, value], ..._setCookieOptions] = setCookie;\n    const setCookieOptions = Object.fromEntries(\n      _setCookieOptions.map(([k, v]) => [k.toLowerCase(), v])\n    );\n    const cookieObject = {\n      name: key,\n      value,\n      domain: setCookieOptions.domain,\n      path: setCookieOptions.path,\n      expires: parseNumberOrDate(setCookieOptions.expires),\n      sameSite: setCookieOptions.samesite,\n      maxAge: parseNumber(setCookieOptions[\"max-age\"]),\n      secure: setCookieStr.includes(\"Secure\") ? true : void 0,\n      httpOnly: setCookieStr.includes(\"HttpOnly\") ? true : void 0\n    };\n    azureCookies.push(cookieObject);\n  }\n  return azureCookies;\n}\nfunction parseNumberOrDate(expires) {\n  const expiresAsNumber = parseNumber(expires);\n  if (expiresAsNumber !== void 0) {\n    return expiresAsNumber;\n  }\n  const expiresAsDate = new Date(expires);\n  if (!Number.isNaN(expiresAsDate.getTime())) {\n    return expiresAsDate;\n  }\n}\nfunction parseNumber(maxAge) {\n  if (!maxAge) {\n    return void 0;\n  }\n  const maxAgeAsNumber = Number(maxAge);\n  if (!Number.isNaN(maxAgeAsNumber)) {\n    return maxAgeAsNumber;\n  }\n}\n","import \"#nitro-internal-pollyfills\";\nimport { useNitroApp } from \"nitropack/runtime\";\nimport {\n  getAzureParsedCookiesFromHeaders,\n  normalizeLambdaOutgoingHeaders\n} from \"nitropack/runtime/internal\";\nimport { parseURL } from \"ufo\";\nconst nitroApp = useNitroApp();\nexport async function handle(context, req) {\n  let url;\n  if (req.headers[\"x-ms-original-url\"]) {\n    const parsedURL = parseURL(req.headers[\"x-ms-original-url\"]);\n    url = parsedURL.pathname + parsedURL.search;\n  } else {\n    url = \"/api/\" + (req.params.url || \"\");\n  }\n  const { body, status, headers } = await nitroApp.localCall({\n    url,\n    headers: req.headers,\n    method: req.method || void 0,\n    // https://github.com/Azure/azure-functions-host/issues/293\n    body: req.rawBody\n  });\n  context.res = {\n    status,\n    cookies: getAzureParsedCookiesFromHeaders(headers),\n    headers: normalizeLambdaOutgoingHeaders(headers, true),\n    body\n  };\n}\n"],"names":["decode","getQuery","defaults","__defProp","__defNormalProp","__publicField","createRouter","EventEmitter","_EventEmitter","createError","parse$1","mergeHeaders","nullBodyResponses","createFetch","nodeFetch","Headers","Headers$1","AbortController$1","$fetch","_inlineAppConfig","normalizeKey","defineDriver","DRIVER_NAME","fsPromises","fsp","createRadixRouter","handlers","nitroApp","createLocalFetch"],"mappings":"","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76]}